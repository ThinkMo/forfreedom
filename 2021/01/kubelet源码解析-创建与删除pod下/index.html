<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.79.0 with theme Tranquilpeak 0.4.8-BETA">
<meta name="author" content="游">
<meta name="keywords" content="k8s, kubelet">
<meta name="description" content="kubeGenericRuntimeManager kubeGenericRuntimeManager为kubelet提供Runtime接口, 管理pods与containers生命周期, 调用remote runtime api完成操作；Kubelet与CRI交互如下图
SyncPod 接上文Pod处理走到调用kubeGenericRuntimeManager.SyncPod
pkg/kubelet/kuberuntime/kuberuntime_manager.go:661
func (m *kubeGenericRuntimeManager) SyncPod(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) { // 获得sandbox、container changes podContainerChanges := m.computePodActions(pod, podStatus) ...... // kill pod if podContainerChanges.KillPod { ....... // 先停止pod中所有conatiners，执行preStop，再停止sandbox killResult := m.killPodWithSyncResult(pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), nil) result.AddPodSyncResult(killResult) if killResult.Error() != nil { klog.Errorf(&quot;killPodWithSyncResult failed: %v&quot;, killResult.Error()) return } // 如果新建sandbox则清楚init containers if podContainerChanges.CreateSandbox { m.purgeInitContainers(pod, podStatus) } } else { // kill掉列表中所有containers，主要是处于未知状态的containers for containerID, containerInfo := range podContainerChanges.">


<meta property="og:description" content="kubeGenericRuntimeManager kubeGenericRuntimeManager为kubelet提供Runtime接口, 管理pods与containers生命周期, 调用remote runtime api完成操作；Kubelet与CRI交互如下图
SyncPod 接上文Pod处理走到调用kubeGenericRuntimeManager.SyncPod
pkg/kubelet/kuberuntime/kuberuntime_manager.go:661
func (m *kubeGenericRuntimeManager) SyncPod(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) { // 获得sandbox、container changes podContainerChanges := m.computePodActions(pod, podStatus) ...... // kill pod if podContainerChanges.KillPod { ....... // 先停止pod中所有conatiners，执行preStop，再停止sandbox killResult := m.killPodWithSyncResult(pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), nil) result.AddPodSyncResult(killResult) if killResult.Error() != nil { klog.Errorf(&quot;killPodWithSyncResult failed: %v&quot;, killResult.Error()) return } // 如果新建sandbox则清楚init containers if podContainerChanges.CreateSandbox { m.purgeInitContainers(pod, podStatus) } } else { // kill掉列表中所有containers，主要是处于未知状态的containers for containerID, containerInfo := range podContainerChanges.">
<meta property="og:type" content="article">
<meta property="og:title" content="kubelet源码解析-创建与删除POD(下)">
<meta name="twitter:title" content="kubelet源码解析-创建与删除POD(下)">
<meta property="og:url" content="https://itech.red/2021/01/kubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4pod%E4%B8%8B/">
<meta property="twitter:url" content="https://itech.red/2021/01/kubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4pod%E4%B8%8B/">
<meta property="og:site_name" content="平凡世界">
<meta property="og:description" content="kubeGenericRuntimeManager kubeGenericRuntimeManager为kubelet提供Runtime接口, 管理pods与containers生命周期, 调用remote runtime api完成操作；Kubelet与CRI交互如下图
SyncPod 接上文Pod处理走到调用kubeGenericRuntimeManager.SyncPod
pkg/kubelet/kuberuntime/kuberuntime_manager.go:661
func (m *kubeGenericRuntimeManager) SyncPod(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) { // 获得sandbox、container changes podContainerChanges := m.computePodActions(pod, podStatus) ...... // kill pod if podContainerChanges.KillPod { ....... // 先停止pod中所有conatiners，执行preStop，再停止sandbox killResult := m.killPodWithSyncResult(pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), nil) result.AddPodSyncResult(killResult) if killResult.Error() != nil { klog.Errorf(&quot;killPodWithSyncResult failed: %v&quot;, killResult.Error()) return } // 如果新建sandbox则清楚init containers if podContainerChanges.CreateSandbox { m.purgeInitContainers(pod, podStatus) } } else { // kill掉列表中所有containers，主要是处于未知状态的containers for containerID, containerInfo := range podContainerChanges.">
<meta name="twitter:description" content="kubeGenericRuntimeManager kubeGenericRuntimeManager为kubelet提供Runtime接口, 管理pods与containers生命周期, 调用remote runtime api完成操作；Kubelet与CRI交互如下图
SyncPod 接上文Pod处理走到调用kubeGenericRuntimeManager.SyncPod
pkg/kubelet/kuberuntime/kuberuntime_manager.go:661
func (m *kubeGenericRuntimeManager) SyncPod(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) { // 获得sandbox、container changes podContainerChanges := m.computePodActions(pod, podStatus) ...... // kill pod if podContainerChanges.KillPod { ....... // 先停止pod中所有conatiners，执行preStop，再停止sandbox killResult := m.killPodWithSyncResult(pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), nil) result.AddPodSyncResult(killResult) if killResult.Error() != nil { klog.Errorf(&quot;killPodWithSyncResult failed: %v&quot;, killResult.Error()) return } // 如果新建sandbox则清楚init containers if podContainerChanges.CreateSandbox { m.purgeInitContainers(pod, podStatus) } } else { // kill掉列表中所有containers，主要是处于未知状态的containers for containerID, containerInfo := range podContainerChanges.">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2021-01-08T15:59:30">
  
  
    <meta property="article:modified_time" content="2021-01-08T15:59:30">
  
  
  
    
      <meta property="article:section" content="k8s">
    
  
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="https://avatars3.githubusercontent.com/u/6330242?v=3&s=460">
  <meta property="twitter:image" content="https://avatars3.githubusercontent.com/u/6330242?v=3&s=460">


    <title>kubelet源码解析-创建与删除POD(下)</title>

    <link rel="icon" href="https://itech.red/favicon.png">
    

    

    <link rel="canonical" href="https://itech.red/2021/01/kubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4pod%E4%B8%8B/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://itech.red/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-82870469-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://itech.red/">平凡世界</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://itech.red/#about">
    
    
    
      
        <img class="header-picture" src="https://avatars3.githubusercontent.com/u/6330242?v=3&amp;s=460" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://itech.red/#about">
          <img class="sidebar-profile-picture" src="https://avatars3.githubusercontent.com/u/6330242?v=3&amp;s=460" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">游</h4>
        
          <h5 class="sidebar-profile-bio">沉下心，多坚持</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://itech.red/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://itech.red/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://itech.red/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://itech.red/external_link">
    
      <i class="sidebar-button-icon fa fa-lg fa-external-link"></i>
      
      <span class="sidebar-button-desc">友链</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://itech.red/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="5"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      kubelet源码解析-创建与删除POD(下)
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2021-01-08T15:59:30&#43;08:00">
        
  
  
  
  
    2021-01-08 15:59:30
  

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://itech.red/categories/k8s">k8s</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <h3 id="kubegenericruntimemanager">kubeGenericRuntimeManager</h3>
<p>kubeGenericRuntimeManager为kubelet提供Runtime接口, 管理pods与containers生命周期, 调用remote runtime api完成操作；Kubelet与CRI交互如下图</p>
<p><img src="https://itech.red/images/cri.png" alt="cri"></p>
<h3 id="syncpod">SyncPod</h3>
<p>接上文Pod处理走到调用kubeGenericRuntimeManager.SyncPod</p>
<p>pkg/kubelet/kuberuntime/kuberuntime_manager.go:661</p>
<pre><code>func (m *kubeGenericRuntimeManager) SyncPod(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) {
	// 获得sandbox、container changes
	podContainerChanges := m.computePodActions(pod, podStatus)
	......
	// kill pod
	if podContainerChanges.KillPod {
	    .......
	    // 先停止pod中所有conatiners，执行preStop，再停止sandbox
		killResult := m.killPodWithSyncResult(pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), nil)
		result.AddPodSyncResult(killResult)
		if killResult.Error() != nil {
			klog.Errorf(&quot;killPodWithSyncResult failed: %v&quot;, killResult.Error())
			return
		}
		// 如果新建sandbox则清楚init containers
		if podContainerChanges.CreateSandbox {
			m.purgeInitContainers(pod, podStatus)
		}
	} else {
		// kill掉列表中所有containers，主要是处于未知状态的containers
		for containerID, containerInfo := range podContainerChanges.ContainersToKill {
			klog.V(3).Infof(&quot;Killing unwanted container %q(id=%q) for pod %q&quot;, containerInfo.name, containerID, format.Pod(pod))
			killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, containerInfo.name)
			result.AddSyncResult(killContainerResult)
			if err := m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, nil); err != nil {
				killContainerResult.Fail(kubecontainer.ErrKillContainer, err.Error())
				klog.Errorf(&quot;killContainer %q(id=%q) for pod %q failed: %v&quot;, containerInfo.name, containerID, format.Pod(pod), err)
				return
			}
		}
	}
	......
	// 创建sandbox
	podSandboxID := podContainerChanges.SandboxID
	if podContainerChanges.CreateSandbox {
		var msg string
		var err error

		klog.V(4).Infof(&quot;Creating PodSandbox for pod %q&quot;, format.Pod(pod))
		createSandboxResult := kubecontainer.NewSyncResult(kubecontainer.CreatePodSandbox, format.Pod(pod))
		result.AddSyncResult(createSandboxResult)
		// 创建sandbox配置、日志目录，调用runtime runSandbox
		podSandboxID, msg, err = m.createPodSandbox(pod, podContainerChanges.Attempt)
		......
	}
	podIP := &quot;&quot;
	if len(podIPs) != 0 {
		podIP = podIPs[0]
	}
	configPodSandboxResult := kubecontainer.NewSyncResult(kubecontainer.ConfigPodSandbox, podSandboxID)
	result.AddSyncResult(configPodSandboxResult)
	// 为container运行生成sandbox config配置，如dns、hostname、端口映射等
	podSandboxConfig, err := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)
	if err != nil {
		message := fmt.Sprintf(&quot;GeneratePodSandboxConfig for pod %q failed: %v&quot;, format.Pod(pod), err)
		klog.Error(message)
		configPodSandboxResult.Fail(kubecontainer.ErrConfigPodSandbox, message)
		return
	}
	// 启动container函数
	start := func(typeName string, spec *startSpec) error {
		// 拉取镜像，创建并启动container，执行post start hook
		if msg, err := m.startContainer(podSandboxID, podSandboxConfig, spec, pod, podStatus, pullSecrets, podIP, podIPs); err != nil {......}
		return nil
	}

	// 启动临时container
	if utilfeature.DefaultFeatureGate.Enabled(features.EphemeralContainers) {
		for _, idx := range podContainerChanges.EphemeralContainersToStart {
			start(&quot;ephemeral container&quot;, ephemeralContainerStartSpec(&amp;pod.Spec.EphemeralContainers[idx]))
		}
	}

	// 启动init container
	if container := podContainerChanges.NextInitContainerToStart; container != nil {
		// Start the next init container.
		if err := start(&quot;init container&quot;, containerStartSpec(container)); err != nil {
			return
		}
		// Successfully started the container; clear the entry in the failure
		klog.V(4).Infof(&quot;Completed init container %q for pod %q&quot;, container.Name, format.Pod(pod))
	}

	// 启动队列中的containers
	for _, idx := range podContainerChanges.ContainersToStart {
		start(&quot;container&quot;, containerStartSpec(&amp;pod.Spec.Containers[idx]))
	}

	return
}
</code></pre><p><strong>SyncPod</strong></p>
<ol>
<li>对比pod、podStatus获得pod、container改变的podContainerChanges</li>
<li>根据podContainerChanges处理已改变的Pod</li>
<li>如果有Pod需要kill，则调用m.killPodWithSyncResult，如果有container需要kill调用m.killContainer</li>
<li>如果有Pod需要创建，先创建sandbox、之后是临时container、init container 最后启动container</li>
</ol>
<h3 id="computepodactions">computePodActions</h3>
<p>pkg/kubelet/kuberuntime/kuberuntime_manager.go:480</p>
<pre><code>func (m *kubeGenericRuntimeManager) computePodActions(pod *v1.Pod, podStatus *kubecontainer.PodStatus) podActions {
    // 判断是否需要新建sandbox，sandbox ready数量!=1、sandbox network namespace change、sandbox 没有ip会重建sandbox
	createPodSandbox, attempt, sandboxID := m.podSandboxChanged(pod, podStatus)
	changes := podActions{
		KillPod:           createPodSandbox,
		CreateSandbox:     createPodSandbox,
		SandboxID:         sandboxID,
		Attempt:           attempt,
		ContainersToStart: []int{},
		ContainersToKill:  make(map[kubecontainer.ContainerID]containerToKillInfo),
	}
	// 需新建sandbox
	if createPodSandbox {
		if !shouldRestartOnFailure(pod) &amp;&amp; attempt != 0 &amp;&amp; len(podStatus.ContainerStatuses) != 0 {
			// pod存在、containers done不需要创建sandbox
			changes.CreateSandbox = false
			return changes
		}
		// 获取需要启动的container
		var containersToStart []int
		for idx, c := range pod.Spec.Containers {
			if pod.Spec.RestartPolicy == v1.RestartPolicyOnFailure &amp;&amp; containerSucceeded(&amp;c, podStatus) {
				continue
			}
			containersToStart = append(containersToStart, idx)
		}
		// 没有container的pod不需要创建sandbox
		if len(containersToStart) == 0 {
			_, _, done := findNextInitContainerToRun(pod, podStatus)
			if done {
				changes.CreateSandbox = false
				return changes
			}
		}
		// 如果有initContainers 加入到podActions
		if len(pod.Spec.InitContainers) != 0 {
			// Pod has init containers, return the first one.
			changes.NextInitContainerToStart = &amp;pod.Spec.InitContainers[0]
			return changes
		}
		changes.ContainersToStart = containersToStart
		return changes
	}
	// 找到init containers
	initLastStatus, next, done := findNextInitContainerToRun(pod, podStatus)
	// 处理未完成的init containers
	if !done {
		if next != nil {
			initFailed := initLastStatus != nil &amp;&amp; isInitContainerFailed(initLastStatus)
			// 如果fail并且restartonfailure则需要置位killPod
			if initFailed &amp;&amp; !shouldRestartOnFailure(pod) {
				changes.KillPod = true
			} else {
				// 将未知状态container加入start队列
				if initLastStatus != nil &amp;&amp; initLastStatus.State == kubecontainer.ContainerStateUnknown {
					changes.ContainersToKill[initLastStatus.ID] = containerToKillInfo{
						name:      next.Name,
						container: next,
						message: fmt.Sprintf(&quot;Init container is in %q state, try killing it before restart&quot;,
							initLastStatus.State),
					}
				}
				changes.NextInitContainerToStart = next
			}
		}
		return changes
	}
	keepCount := 0
	// 遍历检查container的状态
	for idx, container := range pod.Spec.Containers {
		containerStatus := podStatus.FindContainerStatusByName(container.Name)
		// 调用postStop hook，加快资源分配
		if containerStatus != nil &amp;&amp; containerStatus.State != kubecontainer.ContainerStateRunning {
			if err := m.internalLifecycle.PostStopContainer(containerStatus.ID.ID); err != nil {
				klog.Errorf(&quot;internal container post-stop lifecycle hook failed for container %v in pod %v with error %v&quot;,
					container.Name, pod.Name, err)
			}
		}
		// 如果container不存在，或则不再running状态，根据状态、restartPolicy决定是否重启
		if containerStatus == nil || containerStatus.State != kubecontainer.ContainerStateRunning {
			if kubecontainer.ShouldContainerBeRestarted(&amp;container, pod, podStatus) {
				message := fmt.Sprintf(&quot;Container %+v is dead, but RestartPolicy says that we should restart it.&quot;, container)
				klog.V(3).Infof(message)
				changes.ContainersToStart = append(changes.ContainersToStart, idx)
				// 未知状态container需要kill后重启
				if containerStatus != nil &amp;&amp; containerStatus.State == kubecontainer.ContainerStateUnknown {
					changes.ContainersToKill[containerStatus.ID] = containerToKillInfo{
						name:      containerStatus.Name,
						container: &amp;pod.Spec.Containers[idx],
						message: fmt.Sprintf(&quot;Container is in %q state, try killing it before restart&quot;,
							containerStatus.State),
					}
				}
			}
			continue
		}
		// 容器当前状态为running，但满足以下条件需要重启
		var message string
		// policy是否为RestartNever
		restart := shouldRestartOnFailure(pod)
		// 通过对比hash，container spec变了则需要重启
		if _, _, changed := containerChanged(&amp;container, containerStatus); changed {
			message = fmt.Sprintf(&quot;Container %s definition changed&quot;, container.Name)
			// Restart regardless of the restart policy because the container
			// spec changed.
			restart = true
		// liveness检查，失败需要kill，不需重启
		} else if liveness, found := m.livenessManager.Get(containerStatus.ID); found &amp;&amp; liveness == proberesults.Failure {
			// If the container failed the liveness probe, we should kill it.
			message = fmt.Sprintf(&quot;Container %s failed liveness probe&quot;, container.Name)
		// startup探针失败，需要kill，不需重启
		} else if startup, found := m.startupManager.Get(containerStatus.ID); found &amp;&amp; startup == proberesults.Failure {
			// If the container failed the startup probe, we should kill it.
			message = fmt.Sprintf(&quot;Container %s failed startup probe&quot;, container.Name)
		} else {
			// 其他不需要重启
			keepCount++
			continue
		}
		// 处理需重启或kill的container
		// 需要重启的加入重启队列，在被调用函数中总是先kill再start
		if restart {
			message = fmt.Sprintf(&quot;%s, will be restarted&quot;, message)
			changes.ContainersToStart = append(changes.ContainersToStart, idx)
		}
		// 添加需要kill的container
		changes.ContainersToKill[containerStatus.ID] = containerToKillInfo{
			name:      containerStatus.Name,
			container: &amp;pod.Spec.Containers[idx],
			message:   message,
		}
		klog.V(2).Infof(&quot;Container %q (%q) of pod %s: %s&quot;, container.Name, containerStatus.ID, format.Pod(pod), message)
	}
	if keepCount == 0 &amp;&amp; len(changes.ContainersToStart) == 0 {
		changes.KillPod = true
	}
	return changes
}
</code></pre><p><strong>computePodActions</strong>  依此检查sandbox、init container、container的状态，返回变更列表；在SyncPod中是先处理kill Pod再执行创建，所以在重启列表中会的也会加入kill队列</p>
<h3 id="创建podcreatepodsandbox与startcontainer">创建Pod(createPodSandbox与startContainer)</h3>
<pre><code>Kubelet                  KubeletGenericRuntimeManager       RemoteRuntime
   +                              +                               +
   |                              |                               |
   +---------SyncPod-------------&gt;+                               |
   |                              |                               |
   |                              +---- Create PodSandbox -------&gt;+
   |                              +&lt;------------------------------+
   |                              |                               |
   |                              XXXXXXXXXXXX                    |
   |                              |          X                    |
   |                              |    NetworkPlugin.             |
   |                              |       SetupPod                |
   |                              |          X                    |
   |                              XXXXXXXXXXXX                    |
   |                              |                               |
   |                              +&lt;------------------------------+
   |                              +----    Pull image1   --------&gt;+
   |                              +&lt;------------------------------+
   |                              +---- Create container1 -------&gt;+
   |                              +&lt;------------------------------+
   |                              +---- Start container1 --------&gt;+
   |                              +&lt;------------------------------+
   |                              |                               |
   |                              +&lt;------------------------------+
   |                              +----    Pull image2   --------&gt;+
   |                              +&lt;------------------------------+
   |                              +---- Create container2 -------&gt;+
   |                              +&lt;------------------------------+
   |                              +---- Start container2 --------&gt;+
   |                              +&lt;------------------------------+
   |                              |                               |
   | &lt;-------Success--------------+                               |
   |                              |                               |
   +                              +                               +
</code></pre><ul>
<li>createPodSandbox</li>
</ul>
<p>sandbox(沙箱)是一种程序隔离运行机制，为了安全在限定权限下的运行环境；在k8s中可以理解为pause容器，pause容器是pod共享cgroup、namespace的基础</p>
<p>pkg/kubelet/kuberuntime/kuberuntime_sandbox.go:38</p>
<pre><code>func (m *kubeGenericRuntimeManager) createPodSandbox(pod *v1.Pod, attempt uint32) (string, string, error) {
	// 生成pod sandbox配置，包括DNS、hostname、pod log dir、端口映射
	podSandboxConfig, err := m.generatePodSandboxConfig(pod, attempt)
	if err != nil {
		message := fmt.Sprintf(&quot;GeneratePodSandboxConfig for pod %q failed: %v&quot;, format.Pod(pod), err)
		klog.Error(message)
		return &quot;&quot;, message, err
	}
	// 根据sandbox配置创建日志目录
	err = m.osInterface.MkdirAll(podSandboxConfig.LogDirectory, 0755)
	if err != nil {
		message := fmt.Sprintf(&quot;Create pod log directory for pod %q failed: %v&quot;, format.Pod(pod), err)
		klog.Errorf(message)
		return &quot;&quot;, message, err
	}
	runtimeHandler := &quot;&quot;
	if utilfeature.DefaultFeatureGate.Enabled(features.RuntimeClass) &amp;&amp; m.runtimeClassManager != nil {
		runtimeHandler, err = m.runtimeClassManager.LookupRuntimeHandler(pod.Spec.RuntimeClassName)
		if err != nil {
			message := fmt.Sprintf(&quot;CreatePodSandbox for pod %q failed: %v&quot;, format.Pod(pod), err)
			return &quot;&quot;, message, err
		}
		if runtimeHandler != &quot;&quot; {
			klog.V(2).Infof(&quot;Running pod %s with RuntimeHandler %q&quot;, format.Pod(pod), runtimeHandler)
		}
	}
	// 通过runtimeClient启动sandbox，network在这里会设置好
	podSandBoxID, err := m.runtimeService.RunPodSandbox(podSandboxConfig, runtimeHandler)
	if err != nil {
		message := fmt.Sprintf(&quot;CreatePodSandbox for pod %q failed: %v&quot;, format.Pod(pod), err)
		klog.Error(message)
		return &quot;&quot;, message, err
	}

	return podSandBoxID, &quot;&quot;, nil
}
</code></pre><p><strong>createPodSandbox</strong> 函数</p>
<p>1  生成pod sandbox配置，包括DNS、hostname、log dir、端口映射，以及generatePodSandboxLinuxConfig中的cgroup、sysctls、namespace、linux权限；</p>
<p>2  根据配置创建日志目录/var/log/pods/&hellip;</p>
<p>3  调用runtimeService借口启动sandbox</p>
<ul>
<li>startContainer</li>
</ul>
<p>pkg/kubelet/kuberuntime/kuberuntime_container.go:134</p>
<pre><code>func (m *kubeGenericRuntimeManager) startContainer(podSandboxID string, podSandboxConfig *runtimeapi.PodSandboxConfig, spec *startSpec, pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, podIP string, podIPs []string) (string, error) {
	container := spec.container
	// 拉取镜像
	imageRef, msg, err := m.imagePuller.EnsureImageExists(pod, container, pullSecrets, podSandboxConfig)
	if err != nil {
		s, _ := grpcstatus.FromError(err)
		m.recordContainerEvent(pod, container, &quot;&quot;, v1.EventTypeWarning, events.FailedToCreateContainer, &quot;Error: %v&quot;, s.Message())
		return msg, err
	}
	// 更新restartCount
	restartCount := 0
	containerStatus := podStatus.FindContainerStatusByName(container.Name)
	if containerStatus != nil {
		restartCount = containerStatus.RestartCount + 1
	}
	target, err := spec.getTargetID(podStatus)
	if err != nil {
		s, _ := grpcstatus.FromError(err)
		m.recordContainerEvent(pod, container, &quot;&quot;, v1.EventTypeWarning, events.FailedToCreateContainer, &quot;Error: %v&quot;, s.Message())
		return s.Message(), ErrCreateContainerConfig
	}
	// 生成容器配置
	containerConfig, cleanupAction, err := m.generateContainerConfig(container, pod, restartCount, podIP, imageRef, podIPs, target)
	if cleanupAction != nil {
		defer cleanupAction()
	}
	if err != nil {
		s, _ := grpcstatus.FromError(err)
		m.recordContainerEvent(pod, container, &quot;&quot;, v1.EventTypeWarning, events.FailedToCreateContainer, &quot;Error: %v&quot;, s.Message())
		return s.Message(), ErrCreateContainerConfig
	}
	// 调用接口创建容器
	containerID, err := m.runtimeService.CreateContainer(podSandboxID, containerConfig, podSandboxConfig)
	if err != nil {
		s, _ := grpcstatus.FromError(err)
		m.recordContainerEvent(pod, container, containerID, v1.EventTypeWarning, events.FailedToCreateContainer, &quot;Error: %v&quot;, s.Message())
		return s.Message(), ErrCreateContainer
	}
	// 容器启动前初始化，主要是cpuManager亲和性加入等
	err = m.internalLifecycle.PreStartContainer(pod, container, containerID)
	if err != nil {
		s, _ := grpcstatus.FromError(err)
		m.recordContainerEvent(pod, container, containerID, v1.EventTypeWarning, events.FailedToStartContainer, &quot;Internal PreStartContainer hook failed: %v&quot;, s.Message())
		return s.Message(), ErrPreStartHook
	}
	m.recordContainerEvent(pod, container, containerID, v1.EventTypeNormal, events.CreatedContainer, fmt.Sprintf(&quot;Created container %s&quot;, container.Name))
	// 启动容器
	err = m.runtimeService.StartContainer(containerID)
	if err != nil {
		s, _ := grpcstatus.FromError(err)
		m.recordContainerEvent(pod, container, containerID, v1.EventTypeWarning, events.FailedToStartContainer, &quot;Error: %v&quot;, s.Message())
		return s.Message(), kubecontainer.ErrRunContainer
	}
	m.recordContainerEvent(pod, container, containerID, v1.EventTypeNormal, events.StartedContainer, fmt.Sprintf(&quot;Started container %s&quot;, container.Name))
	// 执行post hook
	if container.Lifecycle != nil &amp;&amp; container.Lifecycle.PostStart != nil {
		kubeContainerID := kubecontainer.ContainerID{
			Type: m.runtimeName,
			ID:   containerID,
		}
		msg, handlerErr := m.runner.Run(kubeContainerID, pod, container, container.Lifecycle.PostStart)
		if handlerErr != nil {
			m.recordContainerEvent(pod, container, kubeContainerID.ID, v1.EventTypeWarning, events.FailedPostStartHook, msg)
			// 执行失败需要kill container
			if err := m.killContainer(pod, kubeContainerID, container.Name, &quot;FailedPostStartHook&quot;, nil); err != nil {
				klog.Errorf(&quot;Failed to kill container %q(id=%q) in pod %q: %v, %v&quot;,
					container.Name, kubeContainerID.String(), format.Pod(pod), ErrPostStartHook, err)
			}
			return msg, fmt.Errorf(&quot;%s: %v&quot;, ErrPostStartHook, handlerErr)
		}
	}

	return &quot;&quot;, nil
}
</code></pre><p><strong>startContainer</strong>  负责拉取镜像、根据生成的容器配置创建容器，调用启动前hook，然后启动容器，执行postStart hook</p>
<h3 id="删除podkillpodwithsyncresult与killcontainer">删除Pod(killPodWithSyncResult与killContainer</h3>
<pre><code>Kubelet                  KubeletGenericRuntimeManager      RemoteRuntime
   +                              +                               +
   |                              |                               |
   +---------SyncPod-------------&gt;+                               |
   |                              |                               |
   |                              +----   Stop container1   -----&gt;+
   |                              +&lt;------------------------------+
   |                              +----  Delete container1  -----&gt;+
   |                              +&lt;------------------------------+
   |                              |                               |
   |                              +----   Stop container2   ------&gt;+
   |                              +&lt;------------------------------+
   |                              +----  Delete container2  ------&gt;+
   |                              +&lt;------------------------------+
   |                              |                               |
   |                              XXXXXXXXXXXX                    |
   |                              |          X                    |
   |                              |    NetworkPlugin.             |
   |                              |       TeardownPod             |
   |                              |          X                    |
   |                              XXXXXXXXXXXX                    |
   |                              |                               |
   |                              |                               |
   |                              +---- Delete PodSandbox  ------&gt;+
   |                              +&lt;------------------------------+
   |                              |                               |
   | &lt;-------Success--------------+                               |
   |                              |                               |
   +                              +                               +
</code></pre><p>分两种情况，一种是sandbox改变走killPodWithSyncResult，一种是kill container走killContainer而sandbox不变</p>
<ul>
<li>killPodWithSyncResult</li>
</ul>
<p>pkg/kubelet/kuberuntime/kuberuntime_manager.go:896</p>
<pre><code>func (m *kubeGenericRuntimeManager) killPodWithSyncResult(pod *v1.Pod, runningPod kubecontainer.Pod, gracePeriodOverride *int64) (result kubecontainer.PodSyncResult) {
	// 遍历pod container调用killContainer并等待容器停止
	killContainerResults := m.killContainersWithSyncResult(pod, runningPod, gracePeriodOverride)
	for _, containerResult := range killContainerResults {
		result.AddSyncResult(containerResult)
	}
	killSandboxResult := kubecontainer.NewSyncResult(kubecontainer.KillPodSandbox, runningPod.ID)
	result.AddSyncResult(killSandboxResult)
	// 停止所有sandbox
	for _, podSandbox := range runningPod.Sandboxes {
		// pod network在这里被清理
		if err := m.runtimeService.StopPodSandbox(podSandbox.ID.ID); err != nil {
			killSandboxResult.Fail(kubecontainer.ErrKillPodSandbox, err.Error())
			klog.Errorf(&quot;Failed to stop sandbox %q&quot;, podSandbox.ID)
		}
	}

	return
}
</code></pre><p><strong>killPodWithSyncResult</strong> 会先遍历pod container 等待完成kill containers，再调用runtimeService停止sandbox</p>
<ul>
<li>killContainer</li>
</ul>
<p>pkg/kubelet/kuberuntime/kuberuntime_container.go:587</p>
<pre><code>func (m *kubeGenericRuntimeManager) killContainer(pod *v1.Pod, containerID kubecontainer.ContainerID, containerName string, message string, gracePeriodOverride *int64) error {
	// 获取containerSpec
	var containerSpec *v1.Container
	if pod != nil {
		if containerSpec = kubecontainer.GetContainerSpec(pod, containerName); containerSpec == nil {
			return fmt.Errorf(&quot;failed to get containerSpec %q(id=%q) in pod %q when killing container for reason %q&quot;,
				containerName, containerID.String(), format.Pod(pod), message)
		}
	} else {
		// Restore necessary information if one of the specs is nil.
		restoredPod, restoredContainer, err := m.restoreSpecsFromContainerLabels(containerID)
		if err != nil {
			return err
		}
		pod, containerSpec = restoredPod, restoredContainer
	}
	// 优雅停止
	gracePeriod := int64(minimumGracePeriodInSeconds)
	switch {
	case pod.DeletionGracePeriodSeconds != nil:
		gracePeriod = *pod.DeletionGracePeriodSeconds
	case pod.Spec.TerminationGracePeriodSeconds != nil:
		gracePeriod = *pod.Spec.TerminationGracePeriodSeconds
	}
	......
	// 执行preStop
	if err := m.internalLifecycle.PreStopContainer(containerID.ID); err != nil {
		return err
	}
	if containerSpec.Lifecycle != nil &amp;&amp; containerSpec.Lifecycle.PreStop != nil &amp;&amp; gracePeriod &gt; 0 {
		gracePeriod = gracePeriod - m.executePreStopHook(pod, containerID, containerSpec, gracePeriod)
	}
	if gracePeriod &lt; minimumGracePeriodInSeconds {
		gracePeriod = minimumGracePeriodInSeconds
	}
	if gracePeriodOverride != nil {
		gracePeriod = *gracePeriodOverride
		klog.V(3).Infof(&quot;Killing container %q, but using a %d second grace period override&quot;, containerID, gracePeriod)
	}
	klog.V(2).Infof(&quot;Killing container %q with a %d second grace period&quot;, containerID.String(), gracePeriod)
	// 调用接口停止容器
	err := m.runtimeService.StopContainer(containerID.ID, gracePeriod)
	if err != nil {
		klog.Errorf(&quot;Container %q termination failed with gracePeriod %d: %v&quot;, containerID.String(), gracePeriod, err)
	} else {
		klog.V(3).Infof(&quot;Container %q exited normally&quot;, containerID.String())
	}
	return err
}
</code></pre><p><strong>killContainer</strong>  先执行preStop hook再通过runtimeService停止容器</p>
<p>以上是Kubelet创建删除POD的主流程，之后是通过CRI  RuntimeService完成容器的创建与删除，具体说明可以参考<a href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/">Introducing Container Runtime Interface (CRI) in Kubernetes</a>，<a href="https://github.com/opencontainers/runtime-spec">SPEC</a>；其中比较特殊的是dockershim其相当于实现了一个cantainer runtime server，有机会可以深入看下dockershim的实现。</p>

              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://itech.red/2021/02/kubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bpleg/" data-tooltip="kubelet源码解析之PLEG">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://itech.red/2020/12/kubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8Epod%E5%A4%84%E7%90%86%E4%B8%8A/" data-tooltip="kubelet源码解析-启动流程与POD处理(上)">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
                
<div id="lv-container" data-id="city" data-uid="MTAyMC80ODIxMS8yNDcwNw==">
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>


              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2021 <a href="https://github.com/ThinkMo">ThinkMo</a>. All Rights Reserved
  </span>
  <div class="busuanzi-count">
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  </div>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://itech.red/2021/02/kubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bpleg/" data-tooltip="kubelet源码解析之PLEG">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://itech.red/2020/12/kubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8Epod%E5%A4%84%E7%90%86%E4%B8%8A/" data-tooltip="kubelet源码解析-启动流程与POD处理(上)">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://avatars3.githubusercontent.com/u/6330242?v=3&amp;s=460" alt="作者的图片" />
    
    <h4 id="about-card-name">游</h4>
    
      <div id="about-card-bio">沉下心，多坚持</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        SRE
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        杭州
      </div>
    
  </div>
</div>

    

    
  
    <div id="cover" style="background-image:url('https://s2.ax1x.com/2020/01/09/lWSWLR.md.jpg');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://itech.red/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


  
    <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/itech.red\/2021\/01\/kubelet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4pod%E4%B8%8B\/';
          
            this.page.identifier = 'k8s_kubelet_source';
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'MTAyMC80ODIxMS8yNDcwNw==';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




    
  </body>
</html>

