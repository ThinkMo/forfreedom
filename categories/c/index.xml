<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on 平凡世界</title>
    <link>http://www.itech.red/categories/c/index.xml</link>
    <description>Recent content in C on 平凡世界</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://www.itech.red/categories/c/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>C语言结构体封装</title>
      <link>http://www.itech.red/2016/05/c%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%B0%81%E8%A3%85/</link>
      <pubDate>Wed, 11 May 2016 10:23:54 +0800</pubDate>
      
      <guid>http://www.itech.red/2016/05/c%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%B0%81%E8%A3%85/</guid>
      <description>

&lt;h1 id=&#34;c语言结构体封装&#34;&gt;C语言结构体封装&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;源自：&lt;a href=&#34;http://www.catb.org/esr/structure-packing/&#34;&gt;http://www.catb.org/esr/structure-packing/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-简介&#34;&gt;1、简介&lt;/h2&gt;

&lt;p&gt;通过手动填充、封装C语言结构体以减少C程序的内存使用，在嵌入式系统、操作系统内核模块等内存使用有限制的场景，这种知识非常有效。当你对程序的高速缓存行命中率非常在意时，理解这部分知识也是至关重要的。&lt;/p&gt;

&lt;h2 id=&#34;2-对齐&#34;&gt;2、对齐&lt;/h2&gt;

&lt;p&gt;在X86与ARM处理器上，C语言基本类型并不是随意地存储在内存地址上的。除了char，每一个类型都有对齐要求。char可以存储在任何起始地址，2字节short存储的起始地址应为奇数，4字节的int、float起始地址应为4的倍数，8字节long、double起始地址应为8的倍数。C语言的基本类型是自动对齐的。字节对齐使得访问更快速，因为通过单个指令就可以对数据进行读写。如果没有对齐要求，数据可能存储在多个机器字节内，造成访问次数增加。字符是个特例。&lt;/p&gt;

&lt;h2 id=&#34;3-填充&#34;&gt;3、填充&lt;/h2&gt;

&lt;p&gt;如果你不知道数据对齐的知识，你可能认为下面的3个变量会占据连续的内存空间，在32位机器上时，4字节指针、1字节字符和4字节整型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *p;     实际       char *p;     /* 4 or 8 bytes */
char c;     ======&amp;gt;    char c;      /* 1 byte */
int x;                 char pad[3];  /* 3 byte */
                       int x;        /* 4 byte */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上的存储如右所示，pad[3]字符数组为了对齐而浪费的存储空间。看看其他两种情况。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *p;              char *p;      /* 4 or 8 bytes */
char c;     =======&amp;gt;  char c;       /* 1 byte */
short x;              char pad[1];  /* 1 byte */
                      short x;      /* 2 byte */
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;char *p;              char *p;      /* 4 or 8 byte */
char c;     =======&amp;gt;  char c;       /* 1 byte */
long x;               char pad[7];  /* 7 byte */
                      long x;       /* 8 byte */
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;char c;               char c;
char *p;    =======&amp;gt;  char pad1[M];
int x;                char *p;
                      char pad2[N];
                      int x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;N肯定是0，M可能为0-7（大端、小端字符位置决定），为了节省内存空间使用，可以交换x与c的定义位置。&lt;/p&gt;

&lt;h2 id=&#34;4-结构体对齐与填充&#34;&gt;4、结构体对齐与填充&lt;/h2&gt;

&lt;p&gt;实际上，结构体根据最宽的成员长度进行对齐的。编译器通过这种方式可以保证成员对齐提高访问速度。在c中结构体的地址与首个成员的地址相同。下面两个结构体大小均为24bytes。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct foo1 {
    char *p;
    char c;
    long x;
};
struct foo2 {
    char *p;     /* 8 bytes */
    long x;      /* 8 bytes */
    char c;      /* 1 byte */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;struct foo10 {
    char c;
    struct foo10 *p;
    short x;
};
struct foo10 {
    char c;          /* 1 byte */
    char pad1[7];    /* 7 bytes */
    struct foo10 *p; /* 8 bytes */
    short x;         /* 2 bytes */
    char pad2[6];    /* 6 bytes */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改变上面结构体内元素顺序，可以减少内存占用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct foo11 {
    struct foo11 *p;
    short x;
    char c;
};
struct foo11 {
    struct foo11 *p; /* 8 bytes */
    short x;         /* 2 bytes */
    char c;          /* 1 byte */
    char pad[5];     /* 5 bytes */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-位域bitfields&#34;&gt;5、位域Bitfields&lt;/h2&gt;

&lt;p&gt;位域可以使你在结构体成员中声明小于一个字符宽度的成员，甚至一个比特位，C99标准保证在不跨越存储单元边界的情况下尽可能的整合位域。在32位机器上，结构体foo6布局如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct foo6 {
    short s;       /* 2 bytes */
    char c;        /* 1 byte */
    int flip:1;    /* total 1 bit */
    int nybble:4;  /* total 5 bits */
    int pad1:3;    /* pad to an 8-bit boundary */
    int septet:7;  /* 7 bits */
    int pad2:25;   /* pad to 32 bits */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于C标准没有指明位域按从低位到高位分配，结构体foo6布局也可能如下(C99标准没有指定填充)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct foo6 {
    short s;       /* 2 bytes */
    char c;        /* 1 byte */
    int pad1:3;    /* pad to an 8-bit boundary */
    int flip:1;    /* total 1 bit */
    int nybble:4;  /* total 5 bits */
    int pad2:25;   /* pad to 32 bits */
    int septet:7;  /* 7 bits */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;位域不能跨越机器字边界：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct foo7 {
    int bigfield:31;      /* 32-bit word 1 begins */
    int littlefield:1;
};

struct foo8 {
    int bigfield1:31;     /* 32-bit word 1 begins /*
    int littlefield1:1;
    int bigfield2:31;     /* 32-bit word 2 begins */
    int littlefield2:1;
};

struct foo9 {
    int bigfield1:31;     /* 32-bit word 1 begins */
    int bigfield2:31;     /* 32-bit word 2 begins */
    int littlefield1:1;
    int littlefield2:1;   /* 32-bit word 3 begins */
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>