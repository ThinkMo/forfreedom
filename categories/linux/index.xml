<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on 平凡世界</title>
    <link>http://www.itech.red/categories/linux/index.xml</link>
    <description>Recent content in Linux on 平凡世界</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://www.itech.red/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ext2设计与实现(译)</title>
      <link>http://www.itech.red/2017/04/ext2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%91/</link>
      <pubDate>Thu, 06 Apr 2017 19:10:59 +0800</pubDate>
      
      <guid>http://www.itech.red/2017/04/ext2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%91/</guid>
      <description>

&lt;h2 id=&#34;ext2设计与实现&#34;&gt;Ext2设计与实现&lt;/h2&gt;

&lt;h3 id=&#34;1-介绍&#34;&gt;1、介绍&lt;/h3&gt;

&lt;p&gt;Linux第一版只支持Minix文件系统，Minix文件系统有两大亟待解决的限制：块地址存储在16位整型，最大文件大小为64MB；另外目录和文件名长度最大支持14个字符。&lt;/p&gt;

&lt;p&gt;我们设计与实现了两种新的文件系统:EXT 、 EXT2&lt;/p&gt;

&lt;p&gt;在这篇论文中，我们将简述Linux文件系统的历史，简单介绍Unix文件系统的基础概念；介绍Linux VFS层的实现并详细介绍EXT2内核代码与用户工具；最后，是Linux、BSD下EXT2性能测试对比。&lt;/p&gt;

&lt;h3 id=&#34;2-linux文件系统历史-略&#34;&gt;2、Linux文件系统历史（略）&lt;/h3&gt;

&lt;h3 id=&#34;3-文件系统概念&#34;&gt;3、文件系统概念&lt;/h3&gt;

&lt;p&gt;Linux文件系统的实现基于Unix操作系统通用概念：文件通过inodes来表示，目录是一种简单的文件包含许多列表项，设备是可以发起I/O请求的特殊文件。&lt;/p&gt;

&lt;h4 id=&#34;3-1-inode&#34;&gt;3.1 Inode&lt;/h4&gt;

&lt;p&gt;每个文件都使用inode结构体来表示，每个inode包含了描述文件元数据：文件类型、访问权限、所有者、时间戳、大小、数据块指针。分配给文件的数据块地址存储在文件的inode节点中，当用户对文件发起I/O请求时，内核代码将当前文件偏移量转为块号，使用该数字作为块地址表的索引来读写物理块，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://occ9e8dkg.bkt.clouddn.com/ext2-inode.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-2-目录&#34;&gt;3.2 目录&lt;/h4&gt;

&lt;p&gt;目录按层次树结构组织，每一个目录可以包含文件和子目录。&lt;/p&gt;

&lt;p&gt;目录实现为一种特殊的文件。事实上，目录是一种包含列表项的文件，每一项包含一个inode号和一个文件名，当一个进程使用一个路径名时，内核代码会搜索目录查找对应的inode号，在路径文件名被转换为inode号后，inode结构会被存储到内存中用以后序请求。目录如下图：&lt;/p&gt;

&lt;h4 id=&#34;3-3-链接&#34;&gt;3.3 链接&lt;/h4&gt;

&lt;p&gt;Unix文件系统提出了链接的概念，若干个文件名可以关联到一个inode节点，inode节点包含一个存储链接数的域。增加一个链接会创建一个目录项并增加inode链接计数。当删除链接时，内核会递减链接计数，为0时删除inode。&lt;/p&gt;

&lt;p&gt;这种类型的链接称为硬链接，只能在一个文件系统中使用，且不能链接到一个目录，避免引起环路。&lt;/p&gt;

&lt;p&gt;另一种链接存在于大多数Unix系操作系统，符号链接：只包含文件名的简单文件，当内核inode转换时遇到符号链接，会将软链接文件内容替换链接名。因为软链接不包含inode，它可以跨文件系统，可以指向任何类型的文件，甚至不存在的文件。但软链接会占用磁盘空间、inode、在路径名到inode转换时引起额外消耗。&lt;/p&gt;

&lt;h4 id=&#34;3-4-设备文件&#34;&gt;3.4 设备文件&lt;/h4&gt;

&lt;p&gt;在Unix系操作系统，设备被当作特殊文件访问。一个设备文件并不占用文件系统空间，只作为设备驱动访问接口。&lt;/p&gt;

&lt;p&gt;有两类特殊文件：字符设备、块设备。主设备号决定类型，次设备号决定哪一个设备。&lt;/p&gt;

&lt;h3 id=&#34;4-vfs&#34;&gt;4 VFS&lt;/h3&gt;

&lt;p&gt;VFS是一个文件系统抽象层，定义了一个文件系统应该实现的操作，对上层屏蔽了底层不同文件系统的实现，一图概之：
&lt;img src=&#34;http://e2fsprogs.sourceforge.net/ext2-vfs.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-ext2&#34;&gt;5 EXT2&lt;/h3&gt;

&lt;h4 id=&#34;5-1-起因&#34;&gt;5.1 起因&lt;/h4&gt;

&lt;p&gt;修复EXT文件系统问题，提供一个强大的文件系统，实现unix文件语义并提供高级特性&lt;/p&gt;

&lt;h4 id=&#34;5-2-标准-ext2fs特性&#34;&gt;5.2 标准 ext2fs特性&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;支持标准Unix文件类型：普通文件、目录、设备文件、符号链接&lt;/li&gt;
&lt;li&gt;支持最大4TB文件系统&lt;/li&gt;
&lt;li&gt;长文件名：255字节，可扩展至1012&lt;/li&gt;
&lt;li&gt;为root保留空间以便修复&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;5-3-高级-ext2fs特性&#34;&gt;5.3 高级 ext2fs特性&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;属性继承&lt;/li&gt;
&lt;li&gt;软链接：目标名存储在inode中&lt;/li&gt;
&lt;li&gt;创建文件系统时可选择逻辑块大小&lt;/li&gt;
&lt;li&gt;fsck&lt;/li&gt;
&lt;li&gt;mount options&lt;/li&gt;
&lt;li&gt;Append-only files&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;5-4-物理结构&#34;&gt;5.4 物理结构&lt;/h4&gt;

&lt;p&gt;受BSD文件系统的影响，文件系统由块组构成，但块组并没有与磁盘的物理结构块绑定，因为现代驱动趋势是优化顺序访问和对操作系统隐藏物理结构。&lt;/p&gt;

&lt;p&gt;文件系统物理结构：
&lt;table border=&#34;&#34;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Boot&lt;br&gt;Sector&lt;/td&gt;
&lt;td&gt;Block&lt;br&gt;Group 1&lt;/td&gt;
&lt;td&gt;Block&lt;br&gt;Group 2&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;br&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;Block&lt;br&gt;Group N&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;每一个块组包含一份冗余的文件系统控制信息（超级块和文件系统描述信息），并包含一部分文件系统（块位图、inode位图、inode表、数据块）：
&lt;table border=&#34;&#34;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Super&lt;br&gt;Block&lt;/td&gt;
&lt;td&gt;FS&lt;br&gt;descriptors&lt;/td&gt;
&lt;td&gt;Block&lt;br&gt;Bitmap&lt;/td&gt;
&lt;td&gt;Inode&lt;br&gt;Bitmap&lt;/td&gt;
&lt;td&gt;Inode&lt;br&gt;Table&lt;/td&gt;
&lt;td&gt;Data&lt;br&gt;Blocks&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;使用block group提高系统可靠性，冗余超级块信息可以简化文件系统恢复；inode表与数据块一起存储提高寻道时间，提高性能。&lt;/p&gt;

&lt;p&gt;在ext2fs中，目录使用链表管理变长目录项，每一项包含inode号、记录项长度、文件名和文件名长度。通过变长目录项可以实现长文件名同时减少磁盘空间浪费，目录项结构如下：
&lt;table border=&#34;&#34;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;inode number&lt;/td&gt;&lt;td&gt;entry length&lt;/td&gt;
&lt;td&gt;name length&lt;/td&gt;&lt;td&gt;filename&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-5-性能优化&#34;&gt;5.5 性能优化&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;预读：当读取一个块时，内核会请求连续的若干块，当读取下一个块时会从buffer cache读取&lt;/li&gt;
&lt;li&gt;分配优化： 块组的inode、data分配会在当前组中以减少寻道时间&lt;/li&gt;
&lt;li&gt;写时预分配&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-ext2fs-library-略&#34;&gt;6 Ext2fs library （略）&lt;/h3&gt;

&lt;p&gt;译自：&lt;a href=&#34;http://e2fsprogs.sourceforge.net/ext2intro.html&#34;&gt;http://e2fsprogs.sourceforge.net/ext2intro.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux磁盘使用率100%异常排查</title>
      <link>http://www.itech.red/2017/04/linux%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%8E%87100%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</link>
      <pubDate>Sat, 01 Apr 2017 18:00:54 +0800</pubDate>
      
      <guid>http://www.itech.red/2017/04/linux%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%8E%87100%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;缘起&#34;&gt;缘起&lt;/h2&gt;

&lt;p&gt;线上堡垒机系统磁盘根目录/空间使用率100%导致无法添加账号，奇怪的是du查看实际只使用了8G多空间还有40多G，而df查看使用率却是100%，同事找过来让帮忙定位问题。&lt;/p&gt;

&lt;h2 id=&#34;du-h-max-depth-1-x-查看-目录磁盘占用情况-x排除挂载的其他磁盘&#34;&gt;du -h &amp;ndash;max-depth=1 -x 查看/目录磁盘占用情况(-x排除挂载的其他磁盘)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://occ9e8dkg.bkt.clouddn.com/du.png&#34; alt=&#34;du&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;df查看-磁盘使用率在94&#34;&gt;df查看/磁盘使用率在94%&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://occ9e8dkg.bkt.clouddn.com/df.png&#34; alt=&#34;df&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;du与df机制对比&#34;&gt;du与df机制对比&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;df读取的是超级块的内容&lt;/li&gt;
&lt;li&gt;du是将所有文件对象大小加起来&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种机制的不同会造成两者结果不一致的地方，例如你在命令行下删除了一个文件，而这个文件正在被某个程序打开占用，实际上这个文件依然占用磁盘空间，只有在使用该文件的进程关闭时才真正清楚磁盘空间，这时du显示的数据会比df显示的值小。&lt;/p&gt;

&lt;h2 id=&#34;解决思路一&#34;&gt;解决思路一&lt;/h2&gt;

&lt;p&gt;通过lsof查看是否有已删除的文件仍被进程所使用：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lsof | grep &#39;(deleted)&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;找到某个大文件对应的进程，关闭该进程可以正确释放磁盘空间
但该方法在本例中并未解决问题！！！&lt;/p&gt;

&lt;h2 id=&#34;解决思路二&#34;&gt;解决思路二&lt;/h2&gt;

&lt;p&gt;在df的图中可以看到，根目录/下还挂载着/home与/home/admin是否有可能是&lt;strong&gt;原根目录下/home目录被挂载的/home覆盖&lt;/strong&gt;，而原/home目录的数据并未清楚，导致磁盘占用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mount -o bind / /mnt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在mnt下果然看到了原来/home目录，该目录下的废弃的用户账户占用磁盘40G空间！ 之前同事增加磁盘做文件系统粗心导致旧的数据未删除，给自己挖了一个坑！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>认识Linux内核网络参数</title>
      <link>http://www.itech.red/2016/06/%E8%AE%A4%E8%AF%86linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0/</link>
      <pubDate>Fri, 17 Jun 2016 21:03:24 +0800</pubDate>
      
      <guid>http://www.itech.red/2016/06/%E8%AE%A4%E8%AF%86linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0/</guid>
      <description>

&lt;h2 id=&#34;认识linux内核网络参数&#34;&gt;认识Linux内核网络参数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本地端口&lt;/p&gt;

&lt;p&gt;TCP、UDP使用的本地端口范围&lt;/p&gt;

&lt;p&gt;&lt;code&gt;net.ipv4.ip_local_port_range = 1024 65535  （/etc/sysctl.conf，service network restart）&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;优化短链接&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;net.ipv4.tcp_fin_timeout = 15&lt;/td&gt;
&lt;td&gt;处于FIN-WAIT-2状态的时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;net.ipv4.tcp_tw_reuse = 1&lt;/td&gt;
&lt;td&gt;允许将 TIME-WAIT sockets重新用于新的TCP连接&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;net.ipv4.tcp_tw_recycle = 1&lt;/td&gt;
&lt;td&gt;表示开启TCP连接中TIME-WAIT sockets的快速回收&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;缓冲区大小&lt;/p&gt;

&lt;p&gt;套接字的缓冲区大小限制,从Linux2.6.7内核会根据传输情况自动调整&lt;/p&gt;

&lt;p&gt;默认值：&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_rmem = 4096 87380 4194304
net.ipv4.tcp_wmem = 4096 16384 4194304&lt;/p&gt;

&lt;p&gt;TCP读写缓存区，缓存区超过4194304，tcp包会丢弃&lt;/p&gt;

&lt;p&gt;BDP(带宽延时积)=B*D (带宽＊延时)  反推 带宽=BDP/延时   4194304/(0.015*2)/1024/1024=133M/s&lt;/p&gt;

&lt;p&gt;建议值：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;net.core.rmem_default = 262144&lt;/td&gt;
&lt;td&gt;默认套接字接受缓存区大小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;net.core.wmem_default = 262144&lt;/td&gt;
&lt;td&gt;默认套接字发送缓存区大小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;net.core.rmem_max = 16777216&lt;/td&gt;
&lt;td&gt;接收最大值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;net.core.wmem_max = 16777216&lt;/td&gt;
&lt;td&gt;发送最大值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;net.ipv4.tcp_rmem = 4096 87380 16777216&lt;/td&gt;
&lt;td&gt;tcp接收缓存区大小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;net.ipv4.tcp_wmem = 4096 65536 16777216&lt;/td&gt;
&lt;td&gt;tcp发送缓存区大小&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;增大初始拥塞窗口&lt;/p&gt;

&lt;p&gt;依据：慢启动&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;规则
窗口从一个小的值开始
指数增长
上限阈值&lt;/li&gt;
&lt;li&gt;合理性
避免淹没慢的接收方
避免网络瘫痪&lt;/li&gt;
&lt;li&gt;问题
往往慢启动还没终止，连接已经结束
用户的速度极限还没到
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据实验结果进行设置慢启动窗口大小 ip route change&lt;/p&gt;

&lt;p&gt;提高性能百分比，降低TCP重传率的影响&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拥塞控制算法&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_congestion_control = cubic&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务器开发&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;操作的对象是socket读写缓冲区&lt;/li&gt;
&lt;li&gt;send/write成功并不代表已经发送到对端&lt;/li&gt;
&lt;li&gt;应用程序中响应时间的含义&lt;/li&gt;
&lt;li&gt;明白设置缓冲区大小的影响&lt;/li&gt;
&lt;li&gt;关键应用需要保证可靠性&lt;/li&gt;

&lt;li&gt;&lt;p&gt;需要应用级别的心跳检测&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;合理使用重要的TCP选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCP_DEFER_ACCEPT&lt;/li&gt;
&lt;li&gt;TCP_CORK&lt;/li&gt;
&lt;li&gt;TCP_NODELAY&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用writev/readv&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;真正理解non-blocking的套接字编程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;真正理解epoll&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;队列&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Listen队列

&lt;ul&gt;
&lt;li&gt;net.ipv4.tcp_max_syn_backlog = 16384&lt;/li&gt;
&lt;li&gt;net.core.somaxconn = 2048&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;网卡的接收队列

&lt;ul&gt;
&lt;li&gt;net.core.netdev_max_backlog = 10000&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;网卡发送队列&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ifconfig eth0 txqueuelen 10000


&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TCP拥塞控制
手段
    慢启动
    拥塞避免
    快速重传
    快速恢复
目的
    探测网络速度
    保证传输顺畅&lt;/p&gt;

&lt;p&gt;TIME_WAIT
    主动关闭   服务端不主动关闭socket连接，no zuo no die
    2＊MSL
CLOSE_WAIT
    被动关闭
    99%意味着程序有bug  从TCP状态图来看，收到FIN进入CLOSE_WAIT，未关闭socket、发送FIN，停留在该状态&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>进程监视</title>
      <link>http://www.itech.red/2015/09/%E8%BF%9B%E7%A8%8B%E7%9B%91%E8%A7%86/</link>
      <pubDate>Thu, 10 Sep 2015 10:07:34 +0800</pubDate>
      
      <guid>http://www.itech.red/2015/09/%E8%BF%9B%E7%A8%8B%E7%9B%91%E8%A7%86/</guid>
      <description>

&lt;h1 id=&#34;进程监视&#34;&gt;进程监视&lt;/h1&gt;

&lt;h2 id=&#34;1-ps监视进程的主要工具&#34;&gt;1、ps监视进程的主要工具&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ps -ef 查看每一个进程
ps aux 可以展示系统进程的全貌
ps lax 更快，省去了将uid转换为用户名
ps -ejH  or  ps axjf 进程树
ps -eLf  or  ps axms 线程信息
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字段含义&#34;&gt;字段含义&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;USER&lt;/td&gt;
&lt;td&gt;进程属主用户名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PID&lt;/td&gt;
&lt;td&gt;进程ID&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;进程使用CPU百分比&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MEM&lt;/td&gt;
&lt;td&gt;进程使用内存百分比&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;VSZ&lt;/td&gt;
&lt;td&gt;进程虚拟内存大小KiB&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RSS&lt;/td&gt;
&lt;td&gt;驻留集大小，非swap中的内存大小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;STAT&lt;/td&gt;
&lt;td&gt;进程状态 S:可中断睡眠 D:不可中断睡眠 R:running s会话头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;运行时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;COMMAND&lt;/td&gt;
&lt;td&gt;命令行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;NI&lt;/td&gt;
&lt;td&gt;nice值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;WCHAN&lt;/td&gt;
&lt;td&gt;等待的资源&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-top动态查看&#34;&gt;2、top动态查看&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;top对活动进程及所使用的资源情况提供了汇总信息
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-proc文件系统&#34;&gt;3、proc文件系统&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;proc文件系统提供了内核产生的所有状态信息与数据系统，包括进程相关的信息，linux的ps、top都是从/proc目录读取进程的状态信息。进程特有的信息存储在/proc/pid下。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-strace&#34;&gt;4、strace&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;strace -p pid可以追踪进程的系统调用及信号，在调试进程、理解程序执行过程非常有帮助。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-vmstat&#34;&gt;5、vmstat&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;vmstat提供了关于进程、内存、内存页、块IO、陷阱、磁盘及CPU的活动信息。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###字段含义
字段 | 内容
&amp;mdash;- | &amp;mdash;-
r|等待执行的进程数
b|不可中断睡眠的进程数
swpd|使用虚拟内存大小
free|空闲内存
cache|用作cache的内存大小
si|swap in
so|swap out
bi|block in从块设备收到数据块数
bo|block out
in|每秒中断数
cs|每秒上下文切换数
us|user time
sy|system time
id|idle time
wa|wait for io&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>