

  
    
  


  





  

<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.26-DEV">
    <title>Ext2设计与实现(译)</title>
    <meta name="author" content="游">
    <meta name="keywords" content="ext2fs">

    <link rel="icon" href="http://www.itech.red/favicon.png">
    

    
    <meta name="description" content="Ext2设计与实现 1、介绍 Linux第一版只支持Minix文件系统，Minix文件系统有两大亟待解决的限制：块地址存储在16位整型，最大文件大小为64MB；另外目录和文件名长度最大支持14个字符。
我们设计与实现了两种新的文件系统:EXT 、 EXT2
在这篇论文中，我们将简述Linux文件系统的历史，简单介绍Unix文件系统的基础概念；介绍Linux VFS层的实现并详细介绍EXT2内核代码与用户工具；最后，是Linux、BSD下EXT2性能测试对比。
2、Linux文件系统历史（略） 3、文件系统概念 Linux文件系统的实现基于Unix操作系统通用概念：文件通过inodes来表示，目录是一种简单的文件包含许多列表项，设备是可以发起I/O请求的特殊文件。
3.1 Inode 每个文件都使用inode结构体来表示，每个inode包含了描述文件元数据：文件类型、访问权限、所有者、时间戳、大小、数据块指针。分配给文件的数据块地址存储在文件的inode节点中，当用户对文件发起I/O请求时，内核代码将当前文件偏移量转为块号，使用该数字作为块地址表的索引来读写物理块，如下图所示：
3.2 目录 目录按层次树结构组织，每一个目录可以包含文件和子目录。
目录实现为一种特殊的文件。事实上，目录是一种包含列表项的文件，每一项包含一个inode号和一个文件名，当一个进程使用一个路径名时，内核代码会搜索目录查找对应的inode号，在路径文件名被转换为inode号后，inode结构会被存储到内存中用以后序请求。目录如下图：
3.3 链接 Unix文件系统提出了链接的概念，若干个文件名可以关联到一个inode节点，inode节点包含一个存储链接数的域。增加一个链接会创建一个目录项并增加inode链接计数。当删除链接时，内核会递减链接计数，为0时删除inode。
这种类型的链接称为硬链接，只能在一个文件系统中使用，且不能链接到一个目录，避免引起环路。
另一种链接存在于大多数Unix系操作系统，符号链接：只包含文件名的简单文件，当内核inode转换时遇到符号链接，会将软链接文件内容替换链接名。因为软链接不包含inode，它可以跨文件系统，可以指向任何类型的文件，甚至不存在的文件。但软链接会占用磁盘空间、inode、在路径名到inode转换时引起额外消耗。
3.4 设备文件 在Unix系操作系统，设备被当作特殊文件访问。一个设备文件并不占用文件系统空间，只作为设备驱动访问接口。
有两类特殊文件：字符设备、块设备。主设备号决定类型，次设备号决定哪一个设备。
4 VFS VFS是一个文件系统抽象层，定义了一个文件系统应该实现的操作，对上层屏蔽了底层不同文件系统的实现，一图概之： 5 EXT2 5.1 起因 修复EXT文件系统问题，提供一个强大的文件系统，实现unix文件语义并提供高级特性
5.2 标准 ext2fs特性  支持标准Unix文件类型：普通文件、目录、设备文件、符号链接 支持最大4TB文件系统 长文件名：255字节，可扩展至1012 为root保留空间以便修复  5.3 高级 ext2fs特性  属性继承 软链接：目标名存储在inode中 创建文件系统时可选择逻辑块大小 fsck mount options Append-only files  5.4 物理结构 受BSD文件系统的影响，文件系统由块组构成，但块组并没有与磁盘的物理结构块绑定，因为现代驱动趋势是优化顺序访问和对操作系统隐藏物理结构。
文件系统物理结构：  Boot
Sector Block
Group 1 Block
Group 2 &hellip;">
    <meta property="og:description" content="Ext2设计与实现 1、介绍 Linux第一版只支持Minix文件系统，Minix文件系统有两大亟待解决的限制：块地址存储在16位整型，最大文件大小为64MB；另外目录和文件名长度最大支持14个字符。
我们设计与实现了两种新的文件系统:EXT 、 EXT2
在这篇论文中，我们将简述Linux文件系统的历史，简单介绍Unix文件系统的基础概念；介绍Linux VFS层的实现并详细介绍EXT2内核代码与用户工具；最后，是Linux、BSD下EXT2性能测试对比。
2、Linux文件系统历史（略） 3、文件系统概念 Linux文件系统的实现基于Unix操作系统通用概念：文件通过inodes来表示，目录是一种简单的文件包含许多列表项，设备是可以发起I/O请求的特殊文件。
3.1 Inode 每个文件都使用inode结构体来表示，每个inode包含了描述文件元数据：文件类型、访问权限、所有者、时间戳、大小、数据块指针。分配给文件的数据块地址存储在文件的inode节点中，当用户对文件发起I/O请求时，内核代码将当前文件偏移量转为块号，使用该数字作为块地址表的索引来读写物理块，如下图所示：
3.2 目录 目录按层次树结构组织，每一个目录可以包含文件和子目录。
目录实现为一种特殊的文件。事实上，目录是一种包含列表项的文件，每一项包含一个inode号和一个文件名，当一个进程使用一个路径名时，内核代码会搜索目录查找对应的inode号，在路径文件名被转换为inode号后，inode结构会被存储到内存中用以后序请求。目录如下图：
3.3 链接 Unix文件系统提出了链接的概念，若干个文件名可以关联到一个inode节点，inode节点包含一个存储链接数的域。增加一个链接会创建一个目录项并增加inode链接计数。当删除链接时，内核会递减链接计数，为0时删除inode。
这种类型的链接称为硬链接，只能在一个文件系统中使用，且不能链接到一个目录，避免引起环路。
另一种链接存在于大多数Unix系操作系统，符号链接：只包含文件名的简单文件，当内核inode转换时遇到符号链接，会将软链接文件内容替换链接名。因为软链接不包含inode，它可以跨文件系统，可以指向任何类型的文件，甚至不存在的文件。但软链接会占用磁盘空间、inode、在路径名到inode转换时引起额外消耗。
3.4 设备文件 在Unix系操作系统，设备被当作特殊文件访问。一个设备文件并不占用文件系统空间，只作为设备驱动访问接口。
有两类特殊文件：字符设备、块设备。主设备号决定类型，次设备号决定哪一个设备。
4 VFS VFS是一个文件系统抽象层，定义了一个文件系统应该实现的操作，对上层屏蔽了底层不同文件系统的实现，一图概之： 5 EXT2 5.1 起因 修复EXT文件系统问题，提供一个强大的文件系统，实现unix文件语义并提供高级特性
5.2 标准 ext2fs特性  支持标准Unix文件类型：普通文件、目录、设备文件、符号链接 支持最大4TB文件系统 长文件名：255字节，可扩展至1012 为root保留空间以便修复  5.3 高级 ext2fs特性  属性继承 软链接：目标名存储在inode中 创建文件系统时可选择逻辑块大小 fsck mount options Append-only files  5.4 物理结构 受BSD文件系统的影响，文件系统由块组构成，但块组并没有与磁盘的物理结构块绑定，因为现代驱动趋势是优化顺序访问和对操作系统隐藏物理结构。
文件系统物理结构：  Boot
Sector Block
Group 1 Block
Group 2 &hellip;">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Ext2设计与实现(译)">
    <meta property="og:url" content="/2017/04/ext2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%91/">
    <meta property="og:site_name" content="平凡世界">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="平凡世界">
    <meta name="twitter:description" content="Ext2设计与实现 1、介绍 Linux第一版只支持Minix文件系统，Minix文件系统有两大亟待解决的限制：块地址存储在16位整型，最大文件大小为64MB；另外目录和文件名长度最大支持14个字符。
我们设计与实现了两种新的文件系统:EXT 、 EXT2
在这篇论文中，我们将简述Linux文件系统的历史，简单介绍Unix文件系统的基础概念；介绍Linux VFS层的实现并详细介绍EXT2内核代码与用户工具；最后，是Linux、BSD下EXT2性能测试对比。
2、Linux文件系统历史（略） 3、文件系统概念 Linux文件系统的实现基于Unix操作系统通用概念：文件通过inodes来表示，目录是一种简单的文件包含许多列表项，设备是可以发起I/O请求的特殊文件。
3.1 Inode 每个文件都使用inode结构体来表示，每个inode包含了描述文件元数据：文件类型、访问权限、所有者、时间戳、大小、数据块指针。分配给文件的数据块地址存储在文件的inode节点中，当用户对文件发起I/O请求时，内核代码将当前文件偏移量转为块号，使用该数字作为块地址表的索引来读写物理块，如下图所示：
3.2 目录 目录按层次树结构组织，每一个目录可以包含文件和子目录。
目录实现为一种特殊的文件。事实上，目录是一种包含列表项的文件，每一项包含一个inode号和一个文件名，当一个进程使用一个路径名时，内核代码会搜索目录查找对应的inode号，在路径文件名被转换为inode号后，inode结构会被存储到内存中用以后序请求。目录如下图：
3.3 链接 Unix文件系统提出了链接的概念，若干个文件名可以关联到一个inode节点，inode节点包含一个存储链接数的域。增加一个链接会创建一个目录项并增加inode链接计数。当删除链接时，内核会递减链接计数，为0时删除inode。
这种类型的链接称为硬链接，只能在一个文件系统中使用，且不能链接到一个目录，避免引起环路。
另一种链接存在于大多数Unix系操作系统，符号链接：只包含文件名的简单文件，当内核inode转换时遇到符号链接，会将软链接文件内容替换链接名。因为软链接不包含inode，它可以跨文件系统，可以指向任何类型的文件，甚至不存在的文件。但软链接会占用磁盘空间、inode、在路径名到inode转换时引起额外消耗。
3.4 设备文件 在Unix系操作系统，设备被当作特殊文件访问。一个设备文件并不占用文件系统空间，只作为设备驱动访问接口。
有两类特殊文件：字符设备、块设备。主设备号决定类型，次设备号决定哪一个设备。
4 VFS VFS是一个文件系统抽象层，定义了一个文件系统应该实现的操作，对上层屏蔽了底层不同文件系统的实现，一图概之： 5 EXT2 5.1 起因 修复EXT文件系统问题，提供一个强大的文件系统，实现unix文件语义并提供高级特性
5.2 标准 ext2fs特性  支持标准Unix文件类型：普通文件、目录、设备文件、符号链接 支持最大4TB文件系统 长文件名：255字节，可扩展至1012 为root保留空间以便修复  5.3 高级 ext2fs特性  属性继承 软链接：目标名存储在inode中 创建文件系统时可选择逻辑块大小 fsck mount options Append-only files  5.4 物理结构 受BSD文件系统的影响，文件系统由块组构成，但块组并没有与磁盘的物理结构块绑定，因为现代驱动趋势是优化顺序访问和对操作系统隐藏物理结构。
文件系统物理结构：  Boot
Sector Block
Group 1 Block
Group 2 &hellip;">
    
    

    
    

    
      <meta property="og:image" content="https://avatars3.githubusercontent.com/u/6330242?v=3&s=460">
    

    
    
    

    

    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" />
    
    
    <link rel="stylesheet" href="http://www.itech.red/css/style-gwlo24d2hxipxk8bi1sxik0zhlpn9t7ebcmgp9kubmmcjfzlavuyhvbqumhn.min.css" />
    
    

    
      
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-82870649-1', 'auto');
ga('send', 'pageview');
</script>

    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="http://www.itech.red/">平凡世界</a>
  </div>
  
    
      <a class="header-right-picture "
         href="http://www.itech.red/#about">
    
    
    
      
        <img class="header-picture" src="https://avatars3.githubusercontent.com/u/6330242?v=3&amp;s=460" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="http://www.itech.red/#about">
          <img class="sidebar-profile-picture" src="https://avatars3.githubusercontent.com/u/6330242?v=3&amp;s=460" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">游</h4>
        
          <h5 class="sidebar-profile-bio">Follow Your Heart</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://www.itech.red/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://www.itech.red/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://www.itech.red/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/thinkmo" target="_blank">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://www.itech.red/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="5"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      Ext2设计与实现(译)
    </h1>
  
  <div class="postShorten-meta post-meta">
  
    <time itemprop="datePublished" datetime="2017-04-06T19:10:59&#43;08:00">
      
  
  
  
  
    2017-04-06 19:10:59
  

    </time>
  
  
  
  
    <span>发布在</span>
    
      <a class="category-link" href="http://www.itech.red/categories/linux">linux</a>
    
  


</div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              

<h2 id="ext2设计与实现">Ext2设计与实现</h2>

<h3 id="1-介绍">1、介绍</h3>

<p>Linux第一版只支持Minix文件系统，Minix文件系统有两大亟待解决的限制：块地址存储在16位整型，最大文件大小为64MB；另外目录和文件名长度最大支持14个字符。</p>

<p>我们设计与实现了两种新的文件系统:EXT 、 EXT2</p>

<p>在这篇论文中，我们将简述Linux文件系统的历史，简单介绍Unix文件系统的基础概念；介绍Linux VFS层的实现并详细介绍EXT2内核代码与用户工具；最后，是Linux、BSD下EXT2性能测试对比。</p>

<h3 id="2-linux文件系统历史-略">2、Linux文件系统历史（略）</h3>

<h3 id="3-文件系统概念">3、文件系统概念</h3>

<p>Linux文件系统的实现基于Unix操作系统通用概念：文件通过inodes来表示，目录是一种简单的文件包含许多列表项，设备是可以发起I/O请求的特殊文件。</p>

<h4 id="3-1-inode">3.1 Inode</h4>

<p>每个文件都使用inode结构体来表示，每个inode包含了描述文件元数据：文件类型、访问权限、所有者、时间戳、大小、数据块指针。分配给文件的数据块地址存储在文件的inode节点中，当用户对文件发起I/O请求时，内核代码将当前文件偏移量转为块号，使用该数字作为块地址表的索引来读写物理块，如下图所示：</p>

<p><img src="http://occ9e8dkg.bkt.clouddn.com/ext2-inode.gif" alt="" /></p>

<h4 id="3-2-目录">3.2 目录</h4>

<p>目录按层次树结构组织，每一个目录可以包含文件和子目录。</p>

<p>目录实现为一种特殊的文件。事实上，目录是一种包含列表项的文件，每一项包含一个inode号和一个文件名，当一个进程使用一个路径名时，内核代码会搜索目录查找对应的inode号，在路径文件名被转换为inode号后，inode结构会被存储到内存中用以后序请求。目录如下图：</p>

<h4 id="3-3-链接">3.3 链接</h4>

<p>Unix文件系统提出了链接的概念，若干个文件名可以关联到一个inode节点，inode节点包含一个存储链接数的域。增加一个链接会创建一个目录项并增加inode链接计数。当删除链接时，内核会递减链接计数，为0时删除inode。</p>

<p>这种类型的链接称为硬链接，只能在一个文件系统中使用，且不能链接到一个目录，避免引起环路。</p>

<p>另一种链接存在于大多数Unix系操作系统，符号链接：只包含文件名的简单文件，当内核inode转换时遇到符号链接，会将软链接文件内容替换链接名。因为软链接不包含inode，它可以跨文件系统，可以指向任何类型的文件，甚至不存在的文件。但软链接会占用磁盘空间、inode、在路径名到inode转换时引起额外消耗。</p>

<h4 id="3-4-设备文件">3.4 设备文件</h4>

<p>在Unix系操作系统，设备被当作特殊文件访问。一个设备文件并不占用文件系统空间，只作为设备驱动访问接口。</p>

<p>有两类特殊文件：字符设备、块设备。主设备号决定类型，次设备号决定哪一个设备。</p>

<h3 id="4-vfs">4 VFS</h3>

<p>VFS是一个文件系统抽象层，定义了一个文件系统应该实现的操作，对上层屏蔽了底层不同文件系统的实现，一图概之：
<img src="http://e2fsprogs.sourceforge.net/ext2-vfs.gif" alt="" /></p>

<h3 id="5-ext2">5 EXT2</h3>

<h4 id="5-1-起因">5.1 起因</h4>

<p>修复EXT文件系统问题，提供一个强大的文件系统，实现unix文件语义并提供高级特性</p>

<h4 id="5-2-标准-ext2fs特性">5.2 标准 ext2fs特性</h4>

<ul>
<li>支持标准Unix文件类型：普通文件、目录、设备文件、符号链接</li>
<li>支持最大4TB文件系统</li>
<li>长文件名：255字节，可扩展至1012</li>
<li>为root保留空间以便修复</li>
</ul>

<h4 id="5-3-高级-ext2fs特性">5.3 高级 ext2fs特性</h4>

<ul>
<li>属性继承</li>
<li>软链接：目标名存储在inode中</li>
<li>创建文件系统时可选择逻辑块大小</li>
<li>fsck</li>
<li>mount options</li>
<li>Append-only files</li>
</ul>

<h4 id="5-4-物理结构">5.4 物理结构</h4>

<p>受BSD文件系统的影响，文件系统由块组构成，但块组并没有与磁盘的物理结构块绑定，因为现代驱动趋势是优化顺序访问和对操作系统隐藏物理结构。</p>

<p>文件系统物理结构：
<table border="">
<tbody><tr>
<td>Boot<br>Sector</td>
<td>Block<br>Group 1</td>
<td>Block<br>Group 2</td>
<td>&hellip;<br>&hellip;</td>
<td>Block<br>Group N</td>
</tr>
</tbody></table></p>

<p>每一个块组包含一份冗余的文件系统控制信息（超级块和文件系统描述信息），并包含一部分文件系统（块位图、inode位图、inode表、数据块）：
<table border="">
<tbody><tr>
<td>Super<br>Block</td>
<td>FS<br>descriptors</td>
<td>Block<br>Bitmap</td>
<td>Inode<br>Bitmap</td>
<td>Inode<br>Table</td>
<td>Data<br>Blocks</td>
</tr>
</tbody></table></p>

<p>使用block group提高系统可靠性，冗余超级块信息可以简化文件系统恢复；inode表与数据块一起存储提高寻道时间，提高性能。</p>

<p>在ext2fs中，目录使用链表管理变长目录项，每一项包含inode号、记录项长度、文件名和文件名长度。通过变长目录项可以实现长文件名同时减少磁盘空间浪费，目录项结构如下：
<table border="">
<tbody><tr>
<td>inode number</td><td>entry length</td>
<td>name length</td><td>filename</td>
</tr>
</tbody></table></p>

<h4 id="5-5-性能优化">5.5 性能优化</h4>

<ul>
<li>预读：当读取一个块时，内核会请求连续的若干块，当读取下一个块时会从buffer cache读取</li>
<li>分配优化： 块组的inode、data分配会在当前组中以减少寻道时间</li>
<li>写时预分配</li>
</ul>

<h3 id="6-ext2fs-library-略">6 Ext2fs library （略）</h3>

<p>译自：<a href="http://e2fsprogs.sourceforge.net/ext2intro.html">http://e2fsprogs.sourceforge.net/ext2intro.html</a></p>

              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
            
            <div class="post-actions-wrap">
  <nav>
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="http://www.itech.red/2017/04/shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/" data-tooltip="shell条件测试总结">
          
            <i class="fa fa-angle-left"></i>
            <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
          </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="http://www.itech.red/2017/04/%E8%AE%A4%E8%AF%86sk_buff%E7%BB%93%E6%9E%84%E4%BD%93/" data-tooltip="认识sk_buff结构体">
          
            <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
            <i class="fa fa-angle-right"></i>
          </a>
        </li>
      
    </ul>
  </nav>
  <ul class="post-actions post-action-share">
    
    
      <li class="post-action">
        <a class="post-action-btn btn btn--default" href="#disqus_thread">
          <i class="fa fa-comment-o"></i>
        </a>
      </li>
    
    <li class="post-action">
      
        <a class="post-action-btn btn btn--default" href="#">
      
        <i class="fa fa-list"></i>
      </a>
    </li>
  </ul>
</div>


            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2017 <a href="https://github.com/ThinkMo">ThinkMo</a>. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
  <nav>
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="http://www.itech.red/2017/04/shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/" data-tooltip="shell条件测试总结">
          
            <i class="fa fa-angle-left"></i>
            <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
          </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="http://www.itech.red/2017/04/%E8%AE%A4%E8%AF%86sk_buff%E7%BB%93%E6%9E%84%E4%BD%93/" data-tooltip="认识sk_buff结构体">
          
            <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
            <i class="fa fa-angle-right"></i>
          </a>
        </li>
      
    </ul>
  </nav>
  <ul class="post-actions post-action-share">
    
    
      <li class="post-action">
        <a class="post-action-btn btn btn--default" href="#disqus_thread">
          <i class="fa fa-comment-o"></i>
        </a>
      </li>
    
    <li class="post-action">
      
        <a class="post-action-btn btn btn--default" href="#">
      
        <i class="fa fa-list"></i>
      </a>
    </li>
  </ul>
</div>


      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <ul class="share-options">
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http%3a%2f%2fwww.itech.red%2f2017%2f04%2fext2%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0%25E8%25AF%2591%2f">
        <i class="fa fa-google-plus"></i><span>分享到 Google&#43;</span>
      </a>
    </li>
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fwww.itech.red%2f2017%2f04%2fext2%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0%25E8%25AF%2591%2f">
        <i class="fa fa-facebook-official"></i><span>分享到 Facebook</span>
      </a>
    </li>
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http%3a%2f%2fwww.itech.red%2f2017%2f04%2fext2%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0%25E8%25AF%2591%2f">
        <i class="fa fa-twitter"></i><span>分享到 Twitter</span>
      </a>
    </li>
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://avatars3.githubusercontent.com/u/6330242?v=3&amp;s=460" alt="作者的图片" />
    
    <h4 id="about-card-name">游</h4>
    
      <div id="about-card-bio">Follow Your Heart</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        云计算研发工程师
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        杭州
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="搜索" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center"></div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://www.itech.red/2017/09/logstash%E8%BF%87%E6%BB%A4%E6%8F%92%E4%BB%B6grok%E6%AD%A3%E5%88%99%E8%A7%A3%E6%9E%90/">
                <h3 class="media-heading">Logstash过滤插件grok正则解析</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Logstash过滤插件grok正则解析 一、grok介绍 grok是Logstash中用来解析非结构化日志数据，将日志转化为可查询的结构化数据的最佳方法，可以用来处理syslog日志、apache等webserver日志、mysql日志以及用户自定义日志。
Logstash自带有120多种预定义好的正则表达式方便用户使用，你可以在 https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns 查看这些正则表达式，你也可以添加自己的匹配规则。
有两个网站可以帮助我们来构建正则表达式去匹配我们的日志：
 http://grokdebug.herokuapp.com http://grokconstructor.appspot.com (推荐)  二、grok基础 grok匹配模式语法为：%{SYNTAX:SEMANTIC:TYPE}
SYNTAX: 正则表达式、预定义的正则表达式名称
SEMANTIC: 标识符，标识匹配后的数据
TYPE: 可选的类型，目前支持int、float
例如：NUMBER可以匹配3.44，IP可以匹配：192.168.21.2
一个复杂的日志格式如下：
192.168.21.2 GET /index.html 15823 0.023  grok匹配模式可以为：
${IP:client} %{WORD:method} %{URIPATHPARAM:request} %{NUMBER:bytes} %{NUMBER:duration}  更加实际的，该条日志可能来自一个文件：
input { file { path =&gt; &quot;/var/log/http.log&quot; } } filter { grok { match =&gt; { &quot;message&quot; =&gt; &quot;%{IP:client} %{WORD:method} %{URIPATHPARAM:request} %{NUMBER:bytes} %{NUMBER:duration}&quot; } } }  在grok过滤后，可以得到额外一下字段：
client: 192.168.21.2 method: GET request: /index.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://www.itech.red/2017/09/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95--use%E6%96%B9%E6%B3%95/">
                <h3 class="media-heading">性能分析方法--USE方法</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">性能分析方法&ndash;USE方法 USE是utilization、saturation、errors的集合，USE方法即：对于所有的资源，查看它的使用率、饱和度和错误。
 资源：所有服务器物理元器件(CPU、Memory&hellip;)，某些软件资源也包含在内，提供有用的指标。 使用率：在规定的时间间隔内，资源用于服务工作的时间百分比；或容量使用百分比。 饱和度：资源不能在服务更多额外工作的程度，通常有等待队列。 错误：错误事件。  分析流程 资源列表与指标 CPU: 插槽(socket)、核(core)、硬件线程(thread)
内存: DRAM
网络接口: 以太网端口
存储设备: 磁盘、SSD、SAS
控制器: 存储、网络
互联: CPU、内存、I/O
软件资源: 互斥锁、线程池、进程/线程容量、文件描述符容量
   资源 类型 指标     CPU 使用率 CPU使用率(单CPU使用率或系统均值)   CPU 饱和度 等待队列长度   内存 使用率 可用空闲内存   内存 饱和度 匿名换页或线程换出、OOM   网络接口 使用率 接收吞吐量/最大带宽,传输吞吐量/最大带宽   存储设备I/O 使用率 设备繁忙百分比   存储设备I/O 饱和度 等待队列长度   存储设备I/O 错误 设备错误    使用建议  使用率：使用率超过60%可能会是问题，短期的100%使用率易被忽视 饱和度：任何程度的饱和度都是问题 错误：错误都是值得研究的  更多 the use method linux performance checklist</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://www.itech.red/2017/07/ansible%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/">
                <h3 class="media-heading">ansible自动化部署配置工具</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">ansible自动化部署配置工具 初识ansible  简介  ansible是运维自动化工具，可以实现系统配置、软件部署，可以通过编排实现更高级的功能如持续集成、热更新等；ansible具有简单易用、安全、agentless等特点，通过ssh来完成与管理节点的交互。
 inventory  ansible管理的主机信息称为inventory，默认存储在/etc/ansible/hosts，也可以在运行时通过-i 指定inventory文件位置，通常为ini格式，如下：
 [jumpserver] 44.33.22.11:1024	ansible_ssh_user=xxx # xxx用户ssh端口1024 [other] 192.168.1.[2:255] # 范围2-255 [localhost] localhost	ansible_connection=local  处于[]中的为组名，一个节点可以在多个组下，组下为机器名可指定端口与参数，支持的参数详情见文档。
 patterns:  ansible执行ad-hoc 命令的基本格式如下：
 ansible &lt;pattern_goes_here&gt; -m &lt;module_name&gt; -a &lt;arguments&gt;  ansible中的模式patterns决定了inventory中哪些主机将执行指定命令，默认是all(*)所有机器，可以指定多个组的集合如other:localhost(并集) other:!localhost(差集)、other:&amp;localhost(交集)等
 ad-hoc命令  ad-hoc命令是指执行简单短小的、无需保存结果的任务
# 查看localhost组的uptime，-m指定模块，默认为command, -a指定参数, -f并发数	ansible localhost -m command -a &quot;/usr/bin/uptime&quot; # -u username切换登录用户 --become 切换到root执行 --become-user otheruser 切换到其他用户执行 ansible localhost -a &quot;/usr/bin/uptime&quot; -u sa # 文件传输 ansible jumpserver -m copy -a &quot;src=/etc/hosts dest=/tmp/hosts mode=600&quot; # 包管理 ansible jumpserver -m yum -a &quot;name=vim state=present&quot; #确保vim包已安装 ansible jumpserver -m yum -a &quot;name=vim state=absent&quot; #vim包卸载 # 用户管理 ansible jumpserver -m user -a &quot;name=xiao password=xxx&quot; #增加用户xiao	# 服务管理 ansible jumpserver -m service -a &quot;name=httpd state=restarted&quot; # 信息收集 ansible jumpserver -m setup   配置优先级   1.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://www.itech.red/2017/04/shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/">
                <h3 class="media-heading">shell条件测试总结</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">在编写shell脚本时，条件测试与判断必不可少，基于测试结果才能做进一步的处理，此文用来回顾下shell脚本中的条件测试。
test([) test有两种格式，即test condition 或 [ condition ](注意条件两边空格)， test主要用来测试文件、字符串及数字。
 逻辑操作符
-a 逻辑与 -o 逻辑或 ! 逻辑非(不是短路求值)
best practise：使用多个[，而不是-a与-o
 good : [ &ldquo;$a&rdquo; = &ldquo;$b&rdquo; ] &amp;&amp; [ &ldquo;$b&rdquo; = &ldquo;$c&rdquo; ] bad : [ &ldquo;$a&rdquo; = &ldquo;$b&rdquo; -a &ldquo;$b&rdquo; = &ldquo;$c&rdquo; ]  文件测试
     参数 含义 参数 含义     -d 目录 -s 文件长度大于0、非空   -f 普通文件 -w 可写   -L 符号链接 -u 文件有suid置位   -r 可读 -x 可执行    例如:</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://www.itech.red/2017/04/ext2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%91/">
                <h3 class="media-heading">Ext2设计与实现(译)</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Ext2设计与实现 1、介绍 Linux第一版只支持Minix文件系统，Minix文件系统有两大亟待解决的限制：块地址存储在16位整型，最大文件大小为64MB；另外目录和文件名长度最大支持14个字符。
我们设计与实现了两种新的文件系统:EXT 、 EXT2
在这篇论文中，我们将简述Linux文件系统的历史，简单介绍Unix文件系统的基础概念；介绍Linux VFS层的实现并详细介绍EXT2内核代码与用户工具；最后，是Linux、BSD下EXT2性能测试对比。
2、Linux文件系统历史（略） 3、文件系统概念 Linux文件系统的实现基于Unix操作系统通用概念：文件通过inodes来表示，目录是一种简单的文件包含许多列表项，设备是可以发起I/O请求的特殊文件。
3.1 Inode 每个文件都使用inode结构体来表示，每个inode包含了描述文件元数据：文件类型、访问权限、所有者、时间戳、大小、数据块指针。分配给文件的数据块地址存储在文件的inode节点中，当用户对文件发起I/O请求时，内核代码将当前文件偏移量转为块号，使用该数字作为块地址表的索引来读写物理块，如下图所示：
3.2 目录 目录按层次树结构组织，每一个目录可以包含文件和子目录。
目录实现为一种特殊的文件。事实上，目录是一种包含列表项的文件，每一项包含一个inode号和一个文件名，当一个进程使用一个路径名时，内核代码会搜索目录查找对应的inode号，在路径文件名被转换为inode号后，inode结构会被存储到内存中用以后序请求。目录如下图：
3.3 链接 Unix文件系统提出了链接的概念，若干个文件名可以关联到一个inode节点，inode节点包含一个存储链接数的域。增加一个链接会创建一个目录项并增加inode链接计数。当删除链接时，内核会递减链接计数，为0时删除inode。
这种类型的链接称为硬链接，只能在一个文件系统中使用，且不能链接到一个目录，避免引起环路。
另一种链接存在于大多数Unix系操作系统，符号链接：只包含文件名的简单文件，当内核inode转换时遇到符号链接，会将软链接文件内容替换链接名。因为软链接不包含inode，它可以跨文件系统，可以指向任何类型的文件，甚至不存在的文件。但软链接会占用磁盘空间、inode、在路径名到inode转换时引起额外消耗。
3.4 设备文件 在Unix系操作系统，设备被当作特殊文件访问。一个设备文件并不占用文件系统空间，只作为设备驱动访问接口。
有两类特殊文件：字符设备、块设备。主设备号决定类型，次设备号决定哪一个设备。
4 VFS VFS是一个文件系统抽象层，定义了一个文件系统应该实现的操作，对上层屏蔽了底层不同文件系统的实现，一图概之： 5 EXT2 5.1 起因 修复EXT文件系统问题，提供一个强大的文件系统，实现unix文件语义并提供高级特性
5.2 标准 ext2fs特性  支持标准Unix文件类型：普通文件、目录、设备文件、符号链接 支持最大4TB文件系统 长文件名：255字节，可扩展至1012 为root保留空间以便修复  5.3 高级 ext2fs特性  属性继承 软链接：目标名存储在inode中 创建文件系统时可选择逻辑块大小 fsck mount options Append-only files  5.4 物理结构 受BSD文件系统的影响，文件系统由块组构成，但块组并没有与磁盘的物理结构块绑定，因为现代驱动趋势是优化顺序访问和对操作系统隐藏物理结构。
文件系统物理结构：  Boot
Sector Block
Group 1 Block
Group 2 &hellip;</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://www.itech.red/2017/04/%E8%AE%A4%E8%AF%86sk_buff%E7%BB%93%E6%9E%84%E4%BD%93/">
                <h3 class="media-heading">认识sk_buff结构体</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">sk_buff结构体 struct sk_buff { /* These two members must be first. */ struct sk_buff *next; struct sk_buff *prev; /* sk_buff双向链表 */ ktime_t tstamp; /* 报文接收时间戳，是个偏移量 */ struct sock *sk; /* 拥有此skb的socket */ struct net_device *dev; /* SKB收发的网络设备 */ /* * This is the control buffer. It is free to use for every * layer. Please put your private variables there. If you * want to keep them across layers you have to do a skb_clone() * first.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://www.itech.red/2017/04/linux%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%8E%87100%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/">
                <h3 class="media-heading">Linux磁盘使用率100%异常排查</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://www.itech.red/2016/11/springmvc%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AEexcel/">
                <h3 class="media-heading">springmvc实现导出数据excel</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2016
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">springmvc实现导出数据excel
最近在项目中要实现将数据导出为excel的功能，研究了下目前springmvc框架下excel导出的方式，在spring 4.3中使用AbstractXlsView来实现，AbstractExcelView已被弃用；但这里介绍的是直接用apache poi实现的一种方式。
 model如下  package red.itech.blog.dao.model; import java.util.Date; /** * Created by you on 16/10/28. */ public class Blog { private String author; private Date createdAt; private String title; private long count; public Blog(){} public Blog(String author, Date createdAt, String title, long count){ this.author = author; this.count = count; this.createdAt = createdAt; this.title =title; } public void setAuthor(String author) { this.author = author; } public void setCreatedAt(Date createdAt) { this.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://www.itech.red/2016/09/springmybatisvelocity%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/">
                <h3 class="media-heading">Spring＋Mybatis＋Velocity项目搭建</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2016
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Spring＋Mybatis＋Velocity项目搭建
一、开发工具
 JDK 1.8.0_91 Intellij IDEA 15.0.6 Mysql 5.5.44 Maven 3  二、新建工程
 新建Maven工程，不选Create from archtype提供的工程模版，为了学习从头开始配置工程，点击next设置工程坐标，然后一路到finish。 &lt;groupId&gt;red.itech&lt;/groupId&gt; &lt;artifactId&gt;blogDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  如果使用git开发，可以新建.gitignore文件，使git忽略idea自动生成的文件（.ignore插件可以帮助生成.gitignore），项目git初始化
# Created by .ignore support plugin (hsz.mobi) .gitignore ### OSX template *.DS_Store # IntelliJ project files .idea *.iml out target gen### Java template *.class # Package Files # *.jar *.war *.ear  三、Spring MVC
 编辑pom.xml添加Spring MVC、servlet依赖如下：
&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://www.itech.red/2016/08/%E7%90%86%E8%A7%A3uml%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB/">
                <h3 class="media-heading">理解UML类图关系</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Aug 8, 2016
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">理解UML类图关系
1、依赖(Dependency)
 关系：uses temporarily，使用关系，作为局部变量、方法参数或者对静态方法的调用 代码示例：
import B; public class A{ public void method1(B b) { // ... } public void method2() { B tempB = new B(); // ... } }  图示(一套带箭头的虚线表示)：
  2、聚合(Aggregation)
 关系：is part of，整体与部分的关系，作为成员变量 代码：
import Engine; public class Car{ private Engine engine; publilc Engine getEngine(){ return engine; } }  图示(一条带空心菱形箭头的直线表示)：
  3、组合(Composition)
 关系：is entirely made of，更强的整体与部分关系，作为成员变量 代码:
import Page; public class Book{ private List&lt;Page&gt; pages; publilc List&lt;Page&gt; getPages(){ return pages; } }  图示(一条带实心菱形箭头直线表示):</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero=""
         data-message-one=""
         data-message-other="">
         15 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('http://www.itech.red/images/test.jpg');"></div>
  


    
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.js"></script>


<script src="http://www.itech.red/js/script-wl33z0n6ocaypepiqrazthtivfrliqijej4rq8ek8gvrv1awftmgjuv8k4zc.min.js"></script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight').each(function(i, block) {
    var code = "";
    hljs.highlightAuto(block.innerText).value.split(/\r\n|\r|\n/).forEach(function(line) {
      code += "<span class=\"line\">" + line + "</span><br>";
    });
    if (code.length > 0) {
      block.innerHTML = code;  
    }
  });
  $('pre > code').each(function(i, block) {
    $(this).addClass('codeblock');
    hljs.highlightBlock(block);
  });
});
</script>

  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'http:\/\/www.itech.red\/2017\/04\/ext2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%91\/';
          
            this.page.identifier = 'ext2fs1712';
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'itech-1';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  





    
  </body>
</html>

