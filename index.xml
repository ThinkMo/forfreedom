<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>平凡世界</title>
    <link>http://www.itech.red/</link>
    <description>Recent content on 平凡世界</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 19 Jan 2018 18:10:59 +0800</lastBuildDate>
    
	<atom:link href="http://www.itech.red/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ElasticSearch索引类型映射</title>
      <link>http://www.itech.red/2018/01/elasticsearch%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84/</link>
      <pubDate>Fri, 19 Jan 2018 18:10:59 +0800</pubDate>
      
      <guid>http://www.itech.red/2018/01/elasticsearch%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84/</guid>
      <description>最近接手维护了几个ELK集群，对接的是IaaS、PaaS服务日志，简单的ELK架构，通过filebeat采集日志，发送到logstash结构化日志然后发送到ElasticSearch，用户可以通过Kibana查看服务日志定位问题、做一些性能分析图表等，同时利用elastalert做日志报警。
在ElasticSearch须要对用户的索引建立合适的类型映射(尤其是int类型)，才可以在kibana中对数据进行分析，关于ES的映射类型可以看这里，需指出的是一旦某个field字段类型确定就很难更改该字段的类型(需reindex)。
Logstash将非结构化数据转化为结构化数据，通过JSON将数据发送给ElasticSearch，所有字段都会被当作string来处理，而ElasticSearch在自动判断字段类型建立映射这方面做的不足，与我们需求不符，那么如何正确建立索引类型映射呢？
一、通过Logstash的grok、mutate确定字段类型
 grok  根据grok官方文档，在grok正则表达式后可以添加一个数据类型，默认是string类型，如果你想使字段类型为int，你可以在表达式后加int，例如%{NUMBER:num:int}，那么num字段会从string类型变为int类型，目前只支持int和float。
 mutate   通过mutate可以将field转化为integer、float、string，例如：
 filter { mutate { convert =&amp;gt; { &amp;quot;num&amp;quot; =&amp;gt; &amp;quot;integer&amp;quot; } } }  二、ElasticSearch mapping template
映射(mappings)决定了一个字段(field)如何被ElasticSearch解释、存储，例如数据{&amp;ldquo;ip&amp;rdquo;:&amp;ldquo;223.5.5.5&amp;rdquo;}发送给ES，ES会将ip字段存储为string类型，而不是ip类型，不能做IP范围查询同时造成存储空间浪费、查询效率低等。不管在Logstash如何转换类型，ElasticSearch不会知道你的用意除非你正确映射。所有整型会存为long，小数会存为float或double，关于最小类型可以看这里，使用integer而不是long会有效的减少ELasticSearch负担。
 映射模版  编写模版文件my_template.json
 { &amp;quot;index_patterns&amp;quot; : &amp;quot;index*&amp;quot;, &amp;quot;version&amp;quot; : 1, &amp;quot;settings&amp;quot; : { &amp;quot;index.refresh_interval&amp;quot; : &amp;quot;5s&amp;quot; }, &amp;quot;mappings&amp;quot; : { &amp;quot;_default_&amp;quot; : { &amp;quot;properties&amp;quot;:{ &amp;quot;host&amp;quot;: { &amp;quot;type&amp;quot; : &amp;quot;string&amp;quot;}, &amp;quot;ip&amp;quot;: {&amp;quot;type&amp;quot; : &amp;quot;ip&amp;quot;}, .... } } } }  上传template.</description>
    </item>
    
    <item>
      <title>Logstash过滤插件grok正则解析</title>
      <link>http://www.itech.red/2017/10/logstash%E8%BF%87%E6%BB%A4%E6%8F%92%E4%BB%B6grok%E6%AD%A3%E5%88%99%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 10 Oct 2017 21:31:09 +0800</pubDate>
      
      <guid>http://www.itech.red/2017/10/logstash%E8%BF%87%E6%BB%A4%E6%8F%92%E4%BB%B6grok%E6%AD%A3%E5%88%99%E8%A7%A3%E6%9E%90/</guid>
      <description>Logstash过滤插件grok正则解析 一、grok介绍 grok是Logstash中用来解析非结构化日志数据，将日志转化为可查询的结构化数据的最佳方法，可以用来处理syslog日志、apache等webserver日志、mysql日志以及用户自定义日志。
Logstash自带有120多种预定义好的正则表达式方便用户使用，你可以在这里查看这些正则表达式，你也可以添加自己的匹配规则。
有两个网站可以帮助我们来构建正则表达式去匹配我们的日志：
 http://grokdebug.herokuapp.com http://grokconstructor.appspot.com (推荐)  二、grok基础 grok匹配模式语法为：%{SYNTAX:SEMANTIC:TYPE}
SYNTAX: 正则表达式、预定义的正则表达式名称
SEMANTIC: 标识符，标识匹配后的数据
TYPE: 可选的类型，目前支持int、float
例如：NUMBER可以匹配3.44，IP可以匹配：192.168.21.2
一个复杂的日志格式如下：
192.168.21.2 GET /index.html 15823 0.023  grok匹配模式可以为：
${IP:client} %{WORD:method} %{URIPATHPARAM:request} %{NUMBER:bytes} %{NUMBER:duration}  更加实际的，该条日志可能来自一个文件：
input { file { path =&amp;gt; &amp;quot;/var/log/http.log&amp;quot; } } filter { grok { match =&amp;gt; { &amp;quot;message&amp;quot; =&amp;gt; &amp;quot;%{IP:client} %{WORD:method} %{URIPATHPARAM:request} %{NUMBER:bytes} %{NUMBER:duration}&amp;quot; } } }  在grok过滤后，可以得到额外一下字段：
client: 192.168.21.2 method: GET request: /index.html bytes: 15823 duration: 0.</description>
    </item>
    
    <item>
      <title>ansible自动化部署配置工具</title>
      <link>http://www.itech.red/2017/07/ansible%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 21 Jul 2017 16:18:29 +0800</pubDate>
      
      <guid>http://www.itech.red/2017/07/ansible%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/</guid>
      <description>ansible自动化部署配置工具 初识ansible  简介  ansible是运维自动化工具，可以实现系统配置、软件部署，可以通过编排实现更高级的功能如持续集成、热更新等；ansible具有简单易用、安全、agentless等特点，通过ssh来完成与管理节点的交互。
 inventory  ansible管理的主机信息称为inventory，默认存储在/etc/ansible/hosts，也可以在运行时通过-i 指定inventory文件位置，通常为ini格式，如下：
 [jumpserver] 44.33.22.11:1024	ansible_ssh_user=xxx # xxx用户ssh端口1024，2.0后参数变为ansible_user [other] 192.168.1.[2:255] # 范围2-255 [localhost] localhost	ansible_connection=local  处于[]中的为组名，一个节点可以在多个组下，组下为机器名可指定端口与参数，支持的参数详情见文档。
 patterns:  ansible执行ad-hoc 命令的基本格式如下：
 ansible &amp;lt;pattern_goes_here&amp;gt; -m &amp;lt;module_name&amp;gt; -a &amp;lt;arguments&amp;gt;  ansible中的模式patterns决定了inventory中哪些主机将执行指定命令，默认是all(*)所有机器，可以指定多个组的集合如other:localhost(并集) other:!localhost(差集)、other:&amp;amp;localhost(交集)等
 ad-hoc命令  ad-hoc命令是指执行简单短小的、无需保存结果的任务
# 查看localhost组的uptime，-m指定模块，默认为command, -a指定参数, -f并发数	ansible localhost -m command -a &amp;quot;/usr/bin/uptime&amp;quot; # -u username切换登录用户 --become 切换到root执行 --become-user otheruser 切换到其他用户执行 ansible localhost -a &amp;quot;/usr/bin/uptime&amp;quot; -u sa # 文件传输 ansible jumpserver -m copy -a &amp;quot;src=/etc/hosts dest=/tmp/hosts mode=600&amp;quot; # 包管理 ansible jumpserver -m yum -a &amp;quot;name=vim state=present&amp;quot; #确保vim包已安装 ansible jumpserver -m yum -a &amp;quot;name=vim state=absent&amp;quot; #vim包卸载 # 用户管理 ansible jumpserver -m user -a &amp;quot;name=xiao password=xxx&amp;quot; #增加用户xiao	# 服务管理 ansible jumpserver -m service -a &amp;quot;name=httpd state=restarted&amp;quot; # 信息收集 ansible jumpserver -m setup   常用配置项   配置项读取顺序如下： * ANSIBLE_CONFIG (一个环境变量) * ansible.</description>
    </item>
    
    <item>
      <title>shell条件测试总结</title>
      <link>http://www.itech.red/2017/04/shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 27 Apr 2017 18:55:34 +0800</pubDate>
      
      <guid>http://www.itech.red/2017/04/shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
      <description>在编写shell脚本时，条件测试与判断必不可少，基于测试结果才能做进一步的处理，此文用来回顾下shell脚本中的条件测试。
test([) test有两种格式，即test condition 或 [ condition ](注意条件两边空格)， test主要用来测试文件、字符串及数字。
 逻辑操作符
-a 逻辑与 -o 逻辑或 ! 逻辑非(不是短路求值)
best practise：使用多个[，而不是-a与-o
 good : [ &amp;ldquo;$a&amp;rdquo; = &amp;ldquo;$b&amp;rdquo; ] &amp;amp;&amp;amp; [ &amp;ldquo;$b&amp;rdquo; = &amp;ldquo;$c&amp;rdquo; ] bad : [ &amp;ldquo;$a&amp;rdquo; = &amp;ldquo;$b&amp;rdquo; -a &amp;ldquo;$b&amp;rdquo; = &amp;ldquo;$c&amp;rdquo; ]  文件测试
     参数 含义 参数 含义     -d 目录 -s 文件长度大于0、非空   -f 普通文件 -w 可写   -L 符号链接 -u 文件有suid置位   -r 可读 -x 可执行    例如:</description>
    </item>
    
    <item>
      <title>Ext2设计与实现(译)</title>
      <link>http://www.itech.red/2017/04/ext2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%91/</link>
      <pubDate>Thu, 06 Apr 2017 19:10:59 +0800</pubDate>
      
      <guid>http://www.itech.red/2017/04/ext2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%91/</guid>
      <description>Ext2设计与实现 1、介绍 Linux第一版只支持Minix文件系统，Minix文件系统有两大亟待解决的限制：块地址存储在16位整型，最大文件大小为64MB；另外目录和文件名长度最大支持14个字符。
我们设计与实现了两种新的文件系统:EXT 、 EXT2
在这篇论文中，我们将简述Linux文件系统的历史，简单介绍Unix文件系统的基础概念；介绍Linux VFS层的实现并详细介绍EXT2内核代码与用户工具；最后，是Linux、BSD下EXT2性能测试对比。
2、Linux文件系统历史（略） 3、文件系统概念 Linux文件系统的实现基于Unix操作系统通用概念：文件通过inodes来表示，目录是一种简单的文件包含许多列表项，设备是可以发起I/O请求的特殊文件。
3.1 Inode 每个文件都使用inode结构体来表示，每个inode包含了描述文件元数据：文件类型、访问权限、所有者、时间戳、大小、数据块指针。分配给文件的数据块地址存储在文件的inode节点中，当用户对文件发起I/O请求时，内核代码将当前文件偏移量转为块号，使用该数字作为块地址表的索引来读写物理块，如下图所示：
3.2 目录 目录按层次树结构组织，每一个目录可以包含文件和子目录。
目录实现为一种特殊的文件。事实上，目录是一种包含列表项的文件，每一项包含一个inode号和一个文件名，当一个进程使用一个路径名时，内核代码会搜索目录查找对应的inode号，在路径文件名被转换为inode号后，inode结构会被存储到内存中用以后序请求。目录如下图：
3.3 链接 Unix文件系统提出了链接的概念，若干个文件名可以关联到一个inode节点，inode节点包含一个存储链接数的域。增加一个链接会创建一个目录项并增加inode链接计数。当删除链接时，内核会递减链接计数，为0时删除inode。
这种类型的链接称为硬链接，只能在一个文件系统中使用，且不能链接到一个目录，避免引起环路。
另一种链接存在于大多数Unix系操作系统，符号链接：只包含文件名的简单文件，当内核inode转换时遇到符号链接，会将软链接文件内容替换链接名。因为软链接不包含inode，它可以跨文件系统，可以指向任何类型的文件，甚至不存在的文件。但软链接会占用磁盘空间、inode、在路径名到inode转换时引起额外消耗。
3.4 设备文件 在Unix系操作系统，设备被当作特殊文件访问。一个设备文件并不占用文件系统空间，只作为设备驱动访问接口。
有两类特殊文件：字符设备、块设备。主设备号决定类型，次设备号决定哪一个设备。
4 VFS VFS是一个文件系统抽象层，定义了一个文件系统应该实现的操作，对上层屏蔽了底层不同文件系统的实现，一图概之： 5 EXT2 5.1 起因 修复EXT文件系统问题，提供一个强大的文件系统，实现unix文件语义并提供高级特性
5.2 标准 ext2fs特性  支持标准Unix文件类型：普通文件、目录、设备文件、符号链接 支持最大4TB文件系统 长文件名：255字节，可扩展至1012 为root保留空间以便修复  5.3 高级 ext2fs特性  属性继承 软链接：目标名存储在inode中 创建文件系统时可选择逻辑块大小 fsck mount options Append-only files  5.4 物理结构 受BSD文件系统的影响，文件系统由块组构成，但块组并没有与磁盘的物理结构块绑定，因为现代驱动趋势是优化顺序访问和对操作系统隐藏物理结构。
文件系统物理结构：  Boot
Sector Block
Group 1 Block
Group 2 &amp;hellip;</description>
    </item>
    
    <item>
      <title>认识sk_buff结构体</title>
      <link>http://www.itech.red/2017/04/%E8%AE%A4%E8%AF%86sk_buff%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Tue, 04 Apr 2017 19:07:48 +0800</pubDate>
      
      <guid>http://www.itech.red/2017/04/%E8%AE%A4%E8%AF%86sk_buff%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>sk_buff结构体 struct sk_buff { /* These two members must be first. */ struct sk_buff *next; struct sk_buff *prev; /* sk_buff双向链表 */ ktime_t tstamp; /* 报文接收时间戳，是个偏移量 */ struct sock *sk; /* 拥有此skb的socket */ struct net_device *dev; /* SKB收发的网络设备 */ /* * This is the control buffer. It is free to use for every * layer. Please put your private variables there. If you * want to keep them across layers you have to do a skb_clone() * first.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.itech.red/resume/</link>
      <pubDate>Sat, 01 Apr 2017 18:00:54 +0800</pubDate>
      
      <guid>http://www.itech.red/resume/</guid>
      <description> 个人信息  游/男/1988 硕士/电子科技大学计算机与工程学院 英语能力:CET-6 邮箱:tryit0714@gmail.com  工作经历 淘宝(中国)软件软件有限公司（2015年7月～至今） 系统工程师
Kernel/OS自动化测试平台 (2016.11~至今)
集团跳板机系统、大盘与高危审计项目 (2016.4-2016.9)
智能网卡项目 （2015.9-2016.3）
Linux进程级网络流量监控（2015.7）
兴趣方向  Linux下C/C++环境编程、网络编程 Linux内核网络与文件系统 分布式系统 熟悉Java、Python、Shell  </description>
    </item>
    
    <item>
      <title>Linux磁盘使用率100%异常排查</title>
      <link>http://www.itech.red/2017/04/linux%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%8E%87100%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</link>
      <pubDate>Sat, 01 Apr 2017 18:00:54 +0800</pubDate>
      
      <guid>http://www.itech.red/2017/04/linux%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%8E%87100%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>springmvc实现导出数据excel</title>
      <link>http://www.itech.red/2016/11/springmvc%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AEexcel/</link>
      <pubDate>Wed, 23 Nov 2016 18:47:34 +0800</pubDate>
      
      <guid>http://www.itech.red/2016/11/springmvc%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AEexcel/</guid>
      <description>springmvc实现导出数据excel
最近在项目中要实现将数据导出为excel的功能，研究了下目前springmvc框架下excel导出的方式，在spring 4.3中使用AbstractXlsView来实现，AbstractExcelView已被弃用；但这里介绍的是直接用apache poi实现的一种方式。
 model如下  package red.itech.blog.dao.model; import java.util.Date; /** * Created by you on 16/10/28. */ public class Blog { private String author; private Date createdAt; private String title; private long count; public Blog(){} public Blog(String author, Date createdAt, String title, long count){ this.author = author; this.count = count; this.createdAt = createdAt; this.title =title; } public void setAuthor(String author) { this.author = author; } public void setCreatedAt(Date createdAt) { this.</description>
    </item>
    
    <item>
      <title>Spring＋Mybatis＋Velocity项目搭建</title>
      <link>http://www.itech.red/2016/09/springmybatisvelocity%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 28 Sep 2016 15:43:54 +0800</pubDate>
      
      <guid>http://www.itech.red/2016/09/springmybatisvelocity%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</guid>
      <description>Spring＋Mybatis＋Velocity项目搭建
一、开发工具
 JDK 1.8.0_91 Intellij IDEA 15.0.6 Mysql 5.5.44 Maven 3  二、新建工程
 新建Maven工程，不选Create from archtype提供的工程模版，为了学习从头开始配置工程，点击next设置工程坐标，然后一路到finish。 &amp;lt;groupId&amp;gt;red.itech&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;blogDemo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;  如果使用git开发，可以新建.gitignore文件，使git忽略idea自动生成的文件（.ignore插件可以帮助生成.gitignore），项目git初始化
# Created by .ignore support plugin (hsz.mobi) .gitignore ### OSX template *.DS_Store # IntelliJ project files .idea *.iml out target gen### Java template *.class # Package Files # *.jar *.war *.ear  三、Spring MVC
 编辑pom.xml添加Spring MVC、servlet依赖如下：
&amp;lt;dependencies&amp;gt; &amp;lt;!-- spring --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.3.3.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>理解UML类图关系</title>
      <link>http://www.itech.red/2016/08/%E7%90%86%E8%A7%A3uml%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Fri, 26 Aug 2016 16:51:34 +0800</pubDate>
      
      <guid>http://www.itech.red/2016/08/%E7%90%86%E8%A7%A3uml%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB/</guid>
      <description>理解UML类图关系
1、依赖(Dependency)
 关系：uses temporarily，使用关系，作为局部变量、方法参数或者对静态方法的调用 代码示例：
import B; public class A{ public void method1(B b) { // ... } public void method2() { B tempB = new B(); // ... } }  图示(一套带箭头的虚线表示)：
  2、聚合(Aggregation)
 关系：is part of，整体与部分的关系，作为成员变量 代码：
import Engine; public class Car{ private Engine engine; publilc Engine getEngine(){ return engine; } }  图示(一条带空心菱形箭头的直线表示)：
  3、组合(Composition)
 关系：is entirely made of，更强的整体与部分关系，作为成员变量 代码:
import Page; public class Book{ private List&amp;lt;Page&amp;gt; pages; publilc List&amp;lt;Page&amp;gt; getPages(){ return pages; } }  图示(一条带实心菱形箭头直线表示):</description>
    </item>
    
    <item>
      <title>认识Linux内核网络参数</title>
      <link>http://www.itech.red/2016/06/%E8%AE%A4%E8%AF%86linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0/</link>
      <pubDate>Fri, 17 Jun 2016 21:03:24 +0800</pubDate>
      
      <guid>http://www.itech.red/2016/06/%E8%AE%A4%E8%AF%86linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0/</guid>
      <description>认识Linux内核网络参数  本地端口
TCP、UDP使用的本地端口范围
net.ipv4.ip_local_port_range = 1024 65535 （/etc/sysctl.conf，service network restart）
 优化短链接
     选项 含义     net.ipv4.tcp_fin_timeout = 15 处于FIN-WAIT-2状态的时间，建议10   net.ipv4.tcp_tw_reuse = 1 允许将 TIME-WAIT sockets重新用于新的TCP连接   net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收(建议关闭)   net.ipv4.tcp_syncookies 防止syn flood攻击，当syn backlog满时发送syncookies(建议关闭)   net.ipv4.tcp_syn_retries 初始SYN重传次数，默认5   net.ipv4.tcp_keepalive_intvl tcp keepalive探测间隔时间，默认75s，可减小   net.ipv4.tcp_keepalive_probes 最大探测次数，默认9，可减小   net.ipv4.tcp_keepalive_time 只有在SO_KEEPALIVE设置时才启用，链接空闲多久发送keepalive，默认7200s，空闲后大概11min关闭连接，可减小     缓冲区大小</description>
    </item>
    
    <item>
      <title>python项目开发总结</title>
      <link>http://www.itech.red/2016/05/python%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 27 May 2016 13:27:04 +0800</pubDate>
      
      <guid>http://www.itech.red/2016/05/python%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</guid>
      <description>python项目开发总结 编码规范flake8  安装 pip install flake8 或 brew install flake8 安装vim插件 syntastic，语法检测插件，很方便
由于使用vundle管理插件，只需在.vimrc中添加 Plugin &#39;scrooloose/syntastic&#39; 打开vim，在命令行模式输入 PluginInstall 最后在.vimrc中添加set lcs=extends:&amp;gt;,precedes:&amp;lt;,tab:&amp;gt;-,trail:· vundle相关：https://github.com/VundleVim/Vundle.vim   使用virtualenv，独立的开发环境 新建project virtualenv project 环境使能 cd project source bin/activate 退出virtualenv环境 deactive 获得当前环境依赖 pip freeze  python单例  metaclass元类就是用来创建这些类（对象）的，元类就是类的类,type就是Python的内建元类,用来创建类
1) 拦截类的创建 2) 修改类 3) 返回修改之后的类 class Singleton(type): ＃子类化type，__call__相当于重载了括号运算符 _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] class Logger(object): __metaclass__ = Singleton #Or in Python3 class Logger(metaclass=Singleton): pass If you want to run __init__ every time the class is called, add else: cls.</description>
    </item>
    
    <item>
      <title>C语言结构体封装</title>
      <link>http://www.itech.red/2016/05/c%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%B0%81%E8%A3%85/</link>
      <pubDate>Wed, 11 May 2016 10:23:54 +0800</pubDate>
      
      <guid>http://www.itech.red/2016/05/c%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%B0%81%E8%A3%85/</guid>
      <description>C语言结构体封装 源自：http://www.catb.org/esr/structure-packing/
1、简介 通过手动填充、封装C语言结构体以减少C程序的内存使用，在嵌入式系统、操作系统内核模块等内存使用有限制的场景，这种知识非常有效。当你对程序的高速缓存行命中率非常在意时，理解这部分知识也是至关重要的。
2、对齐 在X86与ARM处理器上，C语言基本类型并不是随意地存储在内存地址上的。除了char，每一个类型都有对齐要求。char可以存储在任何起始地址，2字节short存储的起始地址应为奇数，4字节的int、float起始地址应为4的倍数，8字节long、double起始地址应为8的倍数。C语言的基本类型是自动对齐的。字节对齐使得访问更快速，因为通过单个指令就可以对数据进行读写。如果没有对齐要求，数据可能存储在多个机器字节内，造成访问次数增加。字符是个特例。
3、填充 如果你不知道数据对齐的知识，你可能认为下面的3个变量会占据连续的内存空间，在32位机器上时，4字节指针、1字节字符和4字节整型。
char *p; 实际 char *p; /* 4 or 8 bytes */ char c; ======&amp;gt; char c; /* 1 byte */ int x; char pad[3]; /* 3 byte */ int x; /* 4 byte */  实际上的存储如右所示，pad[3]字符数组为了对齐而浪费的存储空间。看看其他两种情况。
char *p; char *p; /* 4 or 8 bytes */ char c; =======&amp;gt; char c; /* 1 byte */ short x; char pad[1]; /* 1 byte */ short x; /* 2 byte */  char *p; char *p; /* 4 or 8 byte */ char c; =======&amp;gt; char c; /* 1 byte */ long x; char pad[7]; /* 7 byte */ long x; /* 8 byte */  char c; char c; char *p; =======&amp;gt; char pad1[M]; int x; char *p; char pad2[N]; int x;  N肯定是0，M可能为0-7（大端、小端字符位置决定），为了节省内存空间使用，可以交换x与c的定义位置。</description>
    </item>
    
    <item>
      <title>进程监视</title>
      <link>http://www.itech.red/2015/09/%E8%BF%9B%E7%A8%8B%E7%9B%91%E8%A7%86/</link>
      <pubDate>Thu, 10 Sep 2015 10:07:34 +0800</pubDate>
      
      <guid>http://www.itech.red/2015/09/%E8%BF%9B%E7%A8%8B%E7%9B%91%E8%A7%86/</guid>
      <description>进程监视 1、ps监视进程的主要工具 ps -ef 查看每一个进程 ps aux 可以展示系统进程的全貌 ps lax 更快，省去了将uid转换为用户名 ps -ejH or ps axjf 进程树 ps -eLf or ps axms 线程信息  字段含义    字段 内容     USER 进程属主用户名   PID 进程ID   CPU 进程使用CPU百分比   MEM 进程使用内存百分比   VSZ 进程虚拟内存大小KiB   RSS 驻留集大小，非swap中的内存大小   STAT 进程状态 S:可中断睡眠 D:不可中断睡眠 R:running s会话头   TIME 运行时间   COMMAND 命令行   NI nice值   WCHAN 等待的资源    2、top动态查看 top对活动进程及所使用的资源情况提供了汇总信息  3、proc文件系统 proc文件系统提供了内核产生的所有状态信息与数据系统，包括进程相关的信息，linux的ps、top都是从/proc目录读取进程的状态信息。进程特有的信息存储在/proc/pid下。  4、strace strace -p pid可以追踪进程的系统调用及信号，在调试进程、理解程序执行过程非常有帮助。  5、vmstat vmstat提供了关于进程、内存、内存页、块IO、陷阱、磁盘及CPU的活动信息。  ###字段含义 字段 | 内容 &amp;mdash;- | &amp;mdash;- r|等待执行的进程数 b|不可中断睡眠的进程数 swpd|使用虚拟内存大小 free|空闲内存 cache|用作cache的内存大小 si|swap in so|swap out bi|block in从块设备收到数据块数 bo|block out in|每秒中断数 cs|每秒上下文切换数 us|user time sy|system time id|idle time wa|wait for io</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.itech.red/base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.itech.red/base/</guid>
      <description>##　知识整理
基础知识 网络  四层网络模型     链路层 处理与传输媒介有关的细节 6smac｜6dmac｜2type｜46-1500｜4crc     网络层 处理分组在网络中的活动 IP协议 20字节   传输层 提供端到端的通信 UDP 8字节 TCP 20字节   应用层 特定应用程序细节 HTTP DNS     HTTP1.0与1.1的区别
 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点  HTTP与HTTPS区别
 HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。 HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。  TCP协议
 IP协议
  数据结构与算法  链表</description>
    </item>
    
  </channel>
</rss>